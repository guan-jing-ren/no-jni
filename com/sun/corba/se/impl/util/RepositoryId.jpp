#ifndef com_sun_corba_se_impl_util_RepositoryId_HPP
#define com_sun_corba_se_impl_util_RepositoryId_HPP

#include "../../../../../../jfwd_decl.hpp"

class ::com::sun::corba::se::impl::util::RepositoryId : public jObject<::com::sun::corba::se::impl::util::RepositoryId, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_corba_se_impl_util / "RepositoryId";

	constexpr static Enume field_signatures{
		jField<::com::sun::corba::se::impl::util::RepositoryIdCache>("cache"), //
		jField<::java::lang::String>("kAnyRepID"), //
		jField<::jint>("kChunkedMask"), //
		jField<::java::lang::String>("kClassDescStubValue"), //
		jField<::java::lang::String>("kClassDescTypeStr"), //
		jField<::java::lang::String>("kClassDescValueHash"), //
		jField<::java::lang::String>("kClassDescValueRepID"), //
		jField<::java::lang::String>("kExternalizableStubValue"), //
		jField<::java::lang::String>("kExternalizableValueHash"), //
		jField<::jint>("kInitialValueTag"), //
		jField<::java::lang::Object *>("kNoArgs"), //
		jField<::java::lang::Class *>("kNoParamTypes"), //
		jField<::jint>("kNoTypeInfo"), //
		jField<::java::lang::String>("kObjectStubValue"), //
		jField<::java::lang::String>("kObjectValueHash"), //
		jField<::jint>("kPartialListTypeInfo"), //
		jField<::jint>("kPreComputed_CodeBaseRMIChunked"), //
		jField<::jint>("kPreComputed_CodeBaseRMIChunked_NoRep"), //
		jField<::jint>("kPreComputed_CodeBaseRMIUnchunked"), //
		jField<::jint>("kPreComputed_CodeBaseRMIUnchunked_NoRep"), //
		jField<::jint>("kPreComputed_StandardRMIChunked"), //
		jField<::jint>("kPreComputed_StandardRMIChunked_NoRep"), //
		jField<::jint>("kPreComputed_StandardRMIUnchunked"), //
		jField<::jint>("kPreComputed_StandardRMIUnchunked_NoRep"), //
		jField<::java::lang::String>("kPrimitiveSequenceValueHash"), //
		jField<::java::lang::String>("kRemoteStubValue"), //
		jField<::java::lang::String>("kRemoteTypeStr"), //
		jField<::java::lang::String>("kRemoteValueHash"), //
		jField<::java::lang::String>("kRemoteValueRepID"), //
		jField<::java::lang::String>("kSequenceValueHash"), //
		jField<::java::lang::String>("kSerializableStubValue"), //
		jField<::java::lang::String>("kSerializableValueHash"), //
		jField<::jint>("kSingleRepTypeInfo"), //
		jField<::java::lang::String>("kWStringStubValue"), //
		jField<::java::lang::String>("kWStringTypeStr"), //
		jField<::java::lang::String>("kWStringValueHash"), //
		jField<::java::lang::String>("kWStringValueRepID"), //
		jField<::java::lang::String>("kWStringValueVersion"), //
		jField<::java::lang::String>("kjava_rmi_Remote"), //
		jField<::java::lang::String>("korg_omg_CORBA_Object"), //
	};

	template<typename F = ::com::sun::corba::se::impl::util::RepositoryIdCache>
	static auto cache() {
		static_assert(field_signatures[jField<F>("cache")] != -1);
		return sat<F>("cache");
	}

	template<typename F = ::java::lang::String>
	static auto kAnyRepID() {
		static_assert(field_signatures[jField<F>("kAnyRepID")] != -1);
		return sat<F>("kAnyRepID");
	}

	template<typename F = ::jint>
	static auto kChunkedMask() {
		static_assert(field_signatures[jField<F>("kChunkedMask")] != -1);
		return sat<F>("kChunkedMask");
	}

	template<typename F = ::java::lang::String>
	static auto kClassDescStubValue() {
		static_assert(field_signatures[jField<F>("kClassDescStubValue")] != -1);
		return sat<F>("kClassDescStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kClassDescTypeStr() {
		static_assert(field_signatures[jField<F>("kClassDescTypeStr")] != -1);
		return sat<F>("kClassDescTypeStr");
	}

	template<typename F = ::java::lang::String>
	static auto kClassDescValueHash() {
		static_assert(field_signatures[jField<F>("kClassDescValueHash")] != -1);
		return sat<F>("kClassDescValueHash");
	}

	template<typename F = ::java::lang::String>
	static auto kClassDescValueRepID() {
		static_assert(field_signatures[jField<F>("kClassDescValueRepID")] != -1);
		return sat<F>("kClassDescValueRepID");
	}

	template<typename F = ::java::lang::String>
	static auto kExternalizableStubValue() {
		static_assert(field_signatures[jField<F>("kExternalizableStubValue")] != -1);
		return sat<F>("kExternalizableStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kExternalizableValueHash() {
		static_assert(field_signatures[jField<F>("kExternalizableValueHash")] != -1);
		return sat<F>("kExternalizableValueHash");
	}

	template<typename F = ::jint>
	static auto kInitialValueTag() {
		static_assert(field_signatures[jField<F>("kInitialValueTag")] != -1);
		return sat<F>("kInitialValueTag");
	}

	template<typename F = ::java::lang::Object *>
	static auto kNoArgs() {
		static_assert(field_signatures[jField<F>("kNoArgs")] != -1);
		return sat<F>("kNoArgs");
	}

	template<typename F = ::java::lang::Class *>
	static auto kNoParamTypes() {
		static_assert(field_signatures[jField<F>("kNoParamTypes")] != -1);
		return sat<F>("kNoParamTypes");
	}

	template<typename F = ::jint>
	static auto kNoTypeInfo() {
		static_assert(field_signatures[jField<F>("kNoTypeInfo")] != -1);
		return sat<F>("kNoTypeInfo");
	}

	template<typename F = ::java::lang::String>
	static auto kObjectStubValue() {
		static_assert(field_signatures[jField<F>("kObjectStubValue")] != -1);
		return sat<F>("kObjectStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kObjectValueHash() {
		static_assert(field_signatures[jField<F>("kObjectValueHash")] != -1);
		return sat<F>("kObjectValueHash");
	}

	template<typename F = ::jint>
	static auto kPartialListTypeInfo() {
		static_assert(field_signatures[jField<F>("kPartialListTypeInfo")] != -1);
		return sat<F>("kPartialListTypeInfo");
	}

	template<typename F = ::jint>
	static auto kPreComputed_CodeBaseRMIChunked() {
		static_assert(field_signatures[jField<F>("kPreComputed_CodeBaseRMIChunked")] != -1);
		return sat<F>("kPreComputed_CodeBaseRMIChunked");
	}

	template<typename F = ::jint>
	static auto kPreComputed_CodeBaseRMIChunked_NoRep() {
		static_assert(field_signatures[jField<F>("kPreComputed_CodeBaseRMIChunked_NoRep")] != -1);
		return sat<F>("kPreComputed_CodeBaseRMIChunked_NoRep");
	}

	template<typename F = ::jint>
	static auto kPreComputed_CodeBaseRMIUnchunked() {
		static_assert(field_signatures[jField<F>("kPreComputed_CodeBaseRMIUnchunked")] != -1);
		return sat<F>("kPreComputed_CodeBaseRMIUnchunked");
	}

	template<typename F = ::jint>
	static auto kPreComputed_CodeBaseRMIUnchunked_NoRep() {
		static_assert(field_signatures[jField<F>("kPreComputed_CodeBaseRMIUnchunked_NoRep")] != -1);
		return sat<F>("kPreComputed_CodeBaseRMIUnchunked_NoRep");
	}

	template<typename F = ::jint>
	static auto kPreComputed_StandardRMIChunked() {
		static_assert(field_signatures[jField<F>("kPreComputed_StandardRMIChunked")] != -1);
		return sat<F>("kPreComputed_StandardRMIChunked");
	}

	template<typename F = ::jint>
	static auto kPreComputed_StandardRMIChunked_NoRep() {
		static_assert(field_signatures[jField<F>("kPreComputed_StandardRMIChunked_NoRep")] != -1);
		return sat<F>("kPreComputed_StandardRMIChunked_NoRep");
	}

	template<typename F = ::jint>
	static auto kPreComputed_StandardRMIUnchunked() {
		static_assert(field_signatures[jField<F>("kPreComputed_StandardRMIUnchunked")] != -1);
		return sat<F>("kPreComputed_StandardRMIUnchunked");
	}

	template<typename F = ::jint>
	static auto kPreComputed_StandardRMIUnchunked_NoRep() {
		static_assert(field_signatures[jField<F>("kPreComputed_StandardRMIUnchunked_NoRep")] != -1);
		return sat<F>("kPreComputed_StandardRMIUnchunked_NoRep");
	}

	template<typename F = ::java::lang::String>
	static auto kPrimitiveSequenceValueHash() {
		static_assert(field_signatures[jField<F>("kPrimitiveSequenceValueHash")] != -1);
		return sat<F>("kPrimitiveSequenceValueHash");
	}

	template<typename F = ::java::lang::String>
	static auto kRemoteStubValue() {
		static_assert(field_signatures[jField<F>("kRemoteStubValue")] != -1);
		return sat<F>("kRemoteStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kRemoteTypeStr() {
		static_assert(field_signatures[jField<F>("kRemoteTypeStr")] != -1);
		return sat<F>("kRemoteTypeStr");
	}

	template<typename F = ::java::lang::String>
	static auto kRemoteValueHash() {
		static_assert(field_signatures[jField<F>("kRemoteValueHash")] != -1);
		return sat<F>("kRemoteValueHash");
	}

	template<typename F = ::java::lang::String>
	static auto kRemoteValueRepID() {
		static_assert(field_signatures[jField<F>("kRemoteValueRepID")] != -1);
		return sat<F>("kRemoteValueRepID");
	}

	template<typename F = ::java::lang::String>
	static auto kSequenceValueHash() {
		static_assert(field_signatures[jField<F>("kSequenceValueHash")] != -1);
		return sat<F>("kSequenceValueHash");
	}

	template<typename F = ::java::lang::String>
	static auto kSerializableStubValue() {
		static_assert(field_signatures[jField<F>("kSerializableStubValue")] != -1);
		return sat<F>("kSerializableStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kSerializableValueHash() {
		static_assert(field_signatures[jField<F>("kSerializableValueHash")] != -1);
		return sat<F>("kSerializableValueHash");
	}

	template<typename F = ::jint>
	static auto kSingleRepTypeInfo() {
		static_assert(field_signatures[jField<F>("kSingleRepTypeInfo")] != -1);
		return sat<F>("kSingleRepTypeInfo");
	}

	template<typename F = ::java::lang::String>
	static auto kWStringStubValue() {
		static_assert(field_signatures[jField<F>("kWStringStubValue")] != -1);
		return sat<F>("kWStringStubValue");
	}

	template<typename F = ::java::lang::String>
	static auto kWStringTypeStr() {
		static_assert(field_signatures[jField<F>("kWStringTypeStr")] != -1);
		return sat<F>("kWStringTypeStr");
	}

	template<typename F = ::java::lang::String>
	static auto kWStringValueHash() {
		static_assert(field_signatures[jField<F>("kWStringValueHash")] != -1);
		return sat<F>("kWStringValueHash");
	}

	template<typename F = ::java::lang::String>
	static auto kWStringValueRepID() {
		static_assert(field_signatures[jField<F>("kWStringValueRepID")] != -1);
		return sat<F>("kWStringValueRepID");
	}

	template<typename F = ::java::lang::String>
	static auto kWStringValueVersion() {
		static_assert(field_signatures[jField<F>("kWStringValueVersion")] != -1);
		return sat<F>("kWStringValueVersion");
	}

	template<typename F = ::java::lang::String>
	static auto kjava_rmi_Remote() {
		static_assert(field_signatures[jField<F>("kjava_rmi_Remote")] != -1);
		return sat<F>("kjava_rmi_Remote");
	}

	template<typename F = ::java::lang::String>
	static auto korg_omg_CORBA_Object() {
		static_assert(field_signatures[jField<F>("korg_omg_CORBA_Object")] != -1);
		return sat<F>("korg_omg_CORBA_Object");
	}

	constexpr static Enume method_signatures{
		jMethod<::jint(::jboolean, ::jint, ::jboolean)>("computeValueTag"), //
		jMethod<::java::lang::String(::java::lang::String)>("convertToISOLatin1"), //
		jMethod<::java::lang::String(::java::lang::Class)>("createForAnyType"), //
		jMethod<::java::lang::String(::java::lang::Class, ::jint, ::jint)>("createForIDLType"), //
		jMethod<::java::lang::String(::java::io::Serializable)>("createForJavaType"), //
		jMethod<::java::lang::String(::java::lang::Class)>("createForJavaType"), //
		jMethod<::java::lang::String(::java::io::Serializable)>("createForSpecialCase"), //
		jMethod<::java::lang::String(::java::lang::Class)>("createForSpecialCase"), //
		jMethod<::java::lang::String(::java::lang::Class)>("createSequenceRepID"), //
		jMethod<::java::lang::String(::java::lang::Object)>("createSequenceRepID"), //
		jMethod<::jlong(::java::lang::String)>("fromHex"), //
		jMethod<::java::lang::String()>("getActualSerialVersionUID"), //
		jMethod<::jlong()>("getActualSerialVersionUIDAsLong"), //
		jMethod<::java::lang::Class()>("getAnyClassFromType"), //
		jMethod<::jbyte *(::java::lang::String)>("getByteArray"), //
		jMethod<::java::lang::Class()>("getClassFromType"), //
		jMethod<::java::lang::Class(::java::lang::Class, ::java::lang::String)>("getClassFromType"), //
		jMethod<::java::lang::Class(::java::lang::String)>("getClassFromType"), //
		jMethod<::java::lang::String()>("getClassName"), //
		jMethod<::java::lang::String()>("getDefinedInId"), //
		jMethod<::java::lang::String()>("getRepositoryId"), //
		jMethod<::java::lang::String()>("getSerialVersionUID"), //
		jMethod<::jlong()>("getSerialVersionUIDAsLong"), //
		jMethod<::java::lang::String()>("getServerURL"), //
		jMethod<::jint(::jint)>("getTypeInfo"), //
		jMethod<::java::lang::String()>("getTypeString"), //
		jMethod<::java::lang::String()>("getUnqualifiedName"), //
		jMethod<::java::lang::String()>("getVersionString"), //
		jMethod<::jboolean(::java::lang::Class)>("isAbstractBase"), //
		jMethod<::jboolean(::java::lang::Class)>("isAnyRequired"), //
		jMethod<::jboolean(::jint)>("isChunkedEncoding"), //
		jMethod<::jboolean(::jint)>("isCodeBasePresent"), //
		jMethod<::jboolean()>("isIDLType"), //
		jMethod<::jboolean()>("isRMIValueType"), //
		jMethod<::jboolean()>("isSequence"), //
		jMethod<::jboolean()>("isSupportedFormat"), //
		jMethod<::jvoid(::java::lang::String, ::jbyte *)>("setByteArray"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::jboolean(::java::lang::Class, ::java::lang::String)>("useFullValueDescription"), //
	};

	template<typename R = ::jint, typename... Args>
	static auto computeValueTag(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("computeValueTag")] != -1);
		return scall<R>("computeValueTag", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto convertToISOLatin1(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("convertToISOLatin1")] != -1);
		return scall<R>("convertToISOLatin1", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto createForAnyType(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createForAnyType")] != -1);
		return scall<R>("createForAnyType", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto createForIDLType(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createForIDLType")] != -1);
		return scall<R>("createForIDLType", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto createForJavaType(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createForJavaType")] != -1);
		return scall<R>("createForJavaType", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto createForSpecialCase(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createForSpecialCase")] != -1);
		return scall<R>("createForSpecialCase", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto createSequenceRepID(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createSequenceRepID")] != -1);
		return scall<R>("createSequenceRepID", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	static auto fromHex(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("fromHex")] != -1);
		return scall<R>("fromHex", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getActualSerialVersionUID(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getActualSerialVersionUID")] != -1);
		return call<R>("getActualSerialVersionUID", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getActualSerialVersionUIDAsLong(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getActualSerialVersionUIDAsLong")] != -1);
		return call<R>("getActualSerialVersionUIDAsLong", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Class, typename... Args>
	auto getAnyClassFromType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAnyClassFromType")] != -1);
		return call<R>("getAnyClassFromType", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	static auto getByteArray(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getByteArray")] != -1);
		return scall<R>("getByteArray", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Class, typename... Args>
	auto getClassFromType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getClassFromType")] != -1);
		return call<R>("getClassFromType", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getClassName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getClassName")] != -1);
		return call<R>("getClassName", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getDefinedInId(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDefinedInId")] != -1);
		return call<R>("getDefinedInId", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getRepositoryId(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRepositoryId")] != -1);
		return call<R>("getRepositoryId", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getSerialVersionUID(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getSerialVersionUID")] != -1);
		return call<R>("getSerialVersionUID", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getSerialVersionUIDAsLong(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getSerialVersionUIDAsLong")] != -1);
		return call<R>("getSerialVersionUIDAsLong", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto getServerURL(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getServerURL")] != -1);
		return scall<R>("getServerURL", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto getTypeInfo(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTypeInfo")] != -1);
		return scall<R>("getTypeInfo", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getTypeString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTypeString")] != -1);
		return call<R>("getTypeString", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getUnqualifiedName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getUnqualifiedName")] != -1);
		return call<R>("getUnqualifiedName", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getVersionString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getVersionString")] != -1);
		return call<R>("getVersionString", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isAbstractBase(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isAbstractBase")] != -1);
		return scall<R>("isAbstractBase", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isAnyRequired(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isAnyRequired")] != -1);
		return scall<R>("isAnyRequired", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isChunkedEncoding(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isChunkedEncoding")] != -1);
		return scall<R>("isChunkedEncoding", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isCodeBasePresent(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isCodeBasePresent")] != -1);
		return scall<R>("isCodeBasePresent", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isIDLType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isIDLType")] != -1);
		return call<R>("isIDLType", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isRMIValueType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isRMIValueType")] != -1);
		return call<R>("isRMIValueType", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSequence(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSequence")] != -1);
		return call<R>("isSequence", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSupportedFormat(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSupportedFormat")] != -1);
		return call<R>("isSupportedFormat", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto setByteArray(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setByteArray")] != -1);
		return scall<R>("setByteArray", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto useFullValueDescription(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useFullValueDescription")] != -1);
		return scall<R>("useFullValueDescription", std::forward<Args>(args)...);
	}

};

#endif
