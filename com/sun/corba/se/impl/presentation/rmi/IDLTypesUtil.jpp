#ifndef com_sun_corba_se_impl_presentation_rmi_IDLTypesUtil_HPP
#define com_sun_corba_se_impl_presentation_rmi_IDLTypesUtil_HPP

#include "../../../../../../../jfwd_decl.hpp"

class ::com::sun::corba::se::impl::presentation::rmi::IDLTypesUtil : public jObject<::com::sun::corba::se::impl::presentation::rmi::IDLTypesUtil, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_corba_se_impl_presentation_rmi / "IDLTypesUtil";

	constexpr static Enume field_signatures{
		jField<::jboolean>("FOLLOW_RMIC"), //
		jField<::jint>("INVALID_TYPE"), //
		jField<::jint>("VALID_TYPE"), //
	};

	template<typename F = ::jboolean>
	static auto FOLLOW_RMIC() {
		static_assert(field_signatures[jField<F>("FOLLOW_RMIC")] != -1);
		return sat<F>("FOLLOW_RMIC");
	}

	template<typename F = ::jint>
	static auto INVALID_TYPE() {
		static_assert(field_signatures[jField<F>("INVALID_TYPE")] != -1);
		return sat<F>("INVALID_TYPE");
	}

	template<typename F = ::jint>
	static auto VALID_TYPE() {
		static_assert(field_signatures[jField<F>("VALID_TYPE")] != -1);
		return sat<F>("VALID_TYPE");
	}

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jMethod<::java::lang::String(::java::lang::String)>("getAttributeNameForProperty"), //
		jMethod<::com::sun::corba::se::impl::presentation::rmi::IDLType(::java::lang::Class)>("getPrimitiveIDLTypeMapping"), //
		jMethod<::com::sun::corba::se::impl::presentation::rmi::IDLType(::java::lang::Class)>("getSpecialCaseIDLTypeMapping"), //
		jMethod<::jboolean(::java::lang::Class)>("isArray"), //
		jMethod<::jboolean(::java::lang::Class)>("isCheckedException"), //
		jMethod<::jboolean(::java::lang::Class)>("isEntity"), //
		jMethod<::jboolean(::java::lang::Class)>("isException"), //
		jMethod<::jboolean(::java::lang::Class)>("isObjectReference"), //
		jMethod<::jboolean(::java::lang::Class)>("isPrimitive"), //
		jMethod<::jboolean(::java::lang::reflect::Method, ::java::lang::Class)>("isPropertyAccessorMethod"), //
		jMethod<::jboolean(::java::lang::Class)>("isRemoteException"), //
		jMethod<::jboolean(::java::lang::Class)>("isRemoteInterface"), //
		jMethod<::jboolean(::java::lang::Class)>("isValue"), //
		jMethod<::jvoid(::java::lang::Class)>("validateRemoteInterface"), //
	};

	template<typename R = ::java::lang::String, typename... Args>
	auto getAttributeNameForProperty(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAttributeNameForProperty")] != -1);
		return call<R>("getAttributeNameForProperty", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::impl::presentation::rmi::IDLType, typename... Args>
	auto getPrimitiveIDLTypeMapping(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getPrimitiveIDLTypeMapping")] != -1);
		return call<R>("getPrimitiveIDLTypeMapping", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::impl::presentation::rmi::IDLType, typename... Args>
	auto getSpecialCaseIDLTypeMapping(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getSpecialCaseIDLTypeMapping")] != -1);
		return call<R>("getSpecialCaseIDLTypeMapping", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isArray(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isArray")] != -1);
		return call<R>("isArray", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isCheckedException(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isCheckedException")] != -1);
		return call<R>("isCheckedException", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isEntity(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isEntity")] != -1);
		return call<R>("isEntity", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isException(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isException")] != -1);
		return call<R>("isException", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isObjectReference(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isObjectReference")] != -1);
		return call<R>("isObjectReference", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isPrimitive(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isPrimitive")] != -1);
		return call<R>("isPrimitive", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isPropertyAccessorMethod(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isPropertyAccessorMethod")] != -1);
		return call<R>("isPropertyAccessorMethod", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isRemoteException(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isRemoteException")] != -1);
		return call<R>("isRemoteException", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isRemoteInterface(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isRemoteInterface")] != -1);
		return call<R>("isRemoteInterface", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isValue(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isValue")] != -1);
		return call<R>("isValue", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto validateRemoteInterface(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("validateRemoteInterface")] != -1);
		return call<R>("validateRemoteInterface", std::forward<Args>(args)...);
	}

};

#endif
