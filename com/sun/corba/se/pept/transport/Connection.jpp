#ifndef com_sun_corba_se_pept_transport_Connection_HPP
#define com_sun_corba_se_pept_transport_Connection_HPP

#include "../../../../../../jfwd_decl.hpp"

class ::com::sun::corba::se::pept::transport::Connection : public jObject<::com::sun::corba::se::pept::transport::Connection, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_corba_se_pept_transport / "Connection";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jvoid()>("close"), //
		jMethod<::com::sun::corba::se::pept::transport::Acceptor()>("getAcceptor"), //
		jMethod<::com::sun::corba::se::pept::transport::ConnectionCache()>("getConnectionCache"), //
		jMethod<::com::sun::corba::se::pept::transport::ContactInfo()>("getContactInfo"), //
		jMethod<::com::sun::corba::se::pept::transport::EventHandler()>("getEventHandler"), //
		jMethod<::jlong()>("getTimeStamp"), //
		jMethod<::jboolean()>("isBusy"), //
		jMethod<::jboolean()>("isServer"), //
		jMethod<::jboolean()>("read"), //
		jMethod<::jvoid(::com::sun::corba::se::pept::protocol::MessageMediator)>("registerWaiter"), //
		jMethod<::jvoid(::com::sun::corba::se::pept::encoding::OutputObject)>("sendWithoutLock"), //
		jMethod<::jvoid(::com::sun::corba::se::pept::transport::ConnectionCache)>("setConnectionCache"), //
		jMethod<::jvoid(::java::lang::String)>("setState"), //
		jMethod<::jvoid(::jlong)>("setTimeStamp"), //
		jMethod<::jboolean()>("shouldRegisterReadEvent"), //
		jMethod<::jboolean()>("shouldRegisterServerReadEvent"), //
		jMethod<::jvoid(::com::sun::corba::se::pept::protocol::MessageMediator)>("unregisterWaiter"), //
		jMethod<::com::sun::corba::se::pept::encoding::InputObject(::com::sun::corba::se::pept::protocol::MessageMediator)>("waitForResponse"), //
		jMethod<::jvoid()>("writeLock"), //
		jMethod<::jvoid()>("writeUnlock"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto close(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("close")] != -1);
		return call<R>("close", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::pept::transport::Acceptor, typename... Args>
	auto getAcceptor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAcceptor")] != -1);
		return call<R>("getAcceptor", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::pept::transport::ConnectionCache, typename... Args>
	auto getConnectionCache(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConnectionCache")] != -1);
		return call<R>("getConnectionCache", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::pept::transport::ContactInfo, typename... Args>
	auto getContactInfo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getContactInfo")] != -1);
		return call<R>("getContactInfo", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::pept::transport::EventHandler, typename... Args>
	auto getEventHandler(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getEventHandler")] != -1);
		return call<R>("getEventHandler", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getTimeStamp(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTimeStamp")] != -1);
		return call<R>("getTimeStamp", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isBusy(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isBusy")] != -1);
		return call<R>("isBusy", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isServer(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isServer")] != -1);
		return call<R>("isServer", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto read(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("read")] != -1);
		return call<R>("read", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto registerWaiter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("registerWaiter")] != -1);
		return call<R>("registerWaiter", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto sendWithoutLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("sendWithoutLock")] != -1);
		return call<R>("sendWithoutLock", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setConnectionCache(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setConnectionCache")] != -1);
		return call<R>("setConnectionCache", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setState(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setState")] != -1);
		return call<R>("setState", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setTimeStamp(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setTimeStamp")] != -1);
		return call<R>("setTimeStamp", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto shouldRegisterReadEvent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("shouldRegisterReadEvent")] != -1);
		return call<R>("shouldRegisterReadEvent", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto shouldRegisterServerReadEvent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("shouldRegisterServerReadEvent")] != -1);
		return call<R>("shouldRegisterServerReadEvent", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unregisterWaiter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("unregisterWaiter")] != -1);
		return call<R>("unregisterWaiter", std::forward<Args>(args)...);
	}

	template<typename R = ::com::sun::corba::se::pept::encoding::InputObject, typename... Args>
	auto waitForResponse(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("waitForResponse")] != -1);
		return call<R>("waitForResponse", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto writeLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("writeLock")] != -1);
		return call<R>("writeLock", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto writeUnlock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("writeUnlock")] != -1);
		return call<R>("writeUnlock", std::forward<Args>(args)...);
	}

};

#endif
