#ifndef com_sun_media_sound_ModelPerformer_HPP
#define com_sun_media_sound_ModelPerformer_HPP

#include "../../../../jfwd_decl.hpp"

class ::com::sun::media::sound::ModelPerformer : public jObject<::com::sun::media::sound::ModelPerformer, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_media_sound / "ModelPerformer";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jMethod<::java::util::List()>("getConnectionBlocks"), //
		jMethod<::jint()>("getExclusiveClass"), //
		jMethod<::jint()>("getKeyFrom"), //
		jMethod<::jint()>("getKeyTo"), //
		jMethod<::java::lang::String()>("getName"), //
		jMethod<::java::util::List()>("getOscillators"), //
		jMethod<::java::lang::Object()>("getUserObject"), //
		jMethod<::jint()>("getVelFrom"), //
		jMethod<::jint()>("getVelTo"), //
		jMethod<::jboolean()>("isDefaultConnectionsEnabled"), //
		jMethod<::jboolean()>("isReleaseTriggered"), //
		jMethod<::jboolean()>("isSelfNonExclusive"), //
		jMethod<::jvoid(::java::util::List)>("setConnectionBlocks"), //
		jMethod<::jvoid(::jboolean)>("setDefaultConnectionsEnabled"), //
		jMethod<::jvoid(::jint)>("setExclusiveClass"), //
		jMethod<::jvoid(::jint)>("setKeyFrom"), //
		jMethod<::jvoid(::jint)>("setKeyTo"), //
		jMethod<::jvoid(::java::lang::String)>("setName"), //
		jMethod<::jvoid(::jboolean)>("setReleaseTriggered"), //
		jMethod<::jvoid(::jboolean)>("setSelfNonExclusive"), //
		jMethod<::jvoid(::java::lang::Object)>("setUserObject"), //
		jMethod<::jvoid(::jint)>("setVelFrom"), //
		jMethod<::jvoid(::jint)>("setVelTo"), //
	};

	template<typename R = ::java::util::List, typename... Args>
	auto getConnectionBlocks(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConnectionBlocks")] != -1);
		return call<R>("getConnectionBlocks", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getExclusiveClass(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getExclusiveClass")] != -1);
		return call<R>("getExclusiveClass", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getKeyFrom(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getKeyFrom")] != -1);
		return call<R>("getKeyFrom", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getKeyTo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getKeyTo")] != -1);
		return call<R>("getKeyTo", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getName")] != -1);
		return call<R>("getName", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::List, typename... Args>
	auto getOscillators(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getOscillators")] != -1);
		return call<R>("getOscillators", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	auto getUserObject(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getUserObject")] != -1);
		return call<R>("getUserObject", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getVelFrom(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getVelFrom")] != -1);
		return call<R>("getVelFrom", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getVelTo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getVelTo")] != -1);
		return call<R>("getVelTo", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isDefaultConnectionsEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isDefaultConnectionsEnabled")] != -1);
		return call<R>("isDefaultConnectionsEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isReleaseTriggered(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isReleaseTriggered")] != -1);
		return call<R>("isReleaseTriggered", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSelfNonExclusive(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSelfNonExclusive")] != -1);
		return call<R>("isSelfNonExclusive", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setConnectionBlocks(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setConnectionBlocks")] != -1);
		return call<R>("setConnectionBlocks", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setDefaultConnectionsEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setDefaultConnectionsEnabled")] != -1);
		return call<R>("setDefaultConnectionsEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setExclusiveClass(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setExclusiveClass")] != -1);
		return call<R>("setExclusiveClass", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setKeyFrom(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setKeyFrom")] != -1);
		return call<R>("setKeyFrom", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setKeyTo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setKeyTo")] != -1);
		return call<R>("setKeyTo", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setName")] != -1);
		return call<R>("setName", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setReleaseTriggered(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setReleaseTriggered")] != -1);
		return call<R>("setReleaseTriggered", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setSelfNonExclusive(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setSelfNonExclusive")] != -1);
		return call<R>("setSelfNonExclusive", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setUserObject(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setUserObject")] != -1);
		return call<R>("setUserObject", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setVelFrom(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setVelFrom")] != -1);
		return call<R>("setVelFrom", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setVelTo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setVelTo")] != -1);
		return call<R>("setVelTo", std::forward<Args>(args)...);
	}

};

#endif
