#ifndef com_sun_awt_AWTUtilities_HPP
#define com_sun_awt_AWTUtilities_HPP

#include "../../../jfwd_decl.hpp"

class ::com::sun::awt::AWTUtilities : public jObject<::com::sun::awt::AWTUtilities, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_awt / "AWTUtilities";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jfloat(::java::awt::Window)>("getWindowOpacity"), //
		jMethod<::java::awt::Shape(::java::awt::Window)>("getWindowShape"), //
		jMethod<::jboolean(::java::awt::GraphicsConfiguration)>("isTranslucencyCapable"), //
		jMethod<::jboolean(::com::sun::awt::AWTUtilities$Translucency)>("isTranslucencySupported"), //
		jMethod<::jboolean(::java::awt::Window)>("isWindowOpaque"), //
		jMethod<::jboolean()>("isWindowShapingSupported"), //
		jMethod<::jvoid(::java::awt::Component, ::java::awt::Shape)>("setComponentMixingCutoutShape"), //
		jMethod<::jvoid(::java::awt::Window, ::jfloat)>("setWindowOpacity"), //
		jMethod<::jvoid(::java::awt::Window, ::jboolean)>("setWindowOpaque"), //
		jMethod<::jvoid(::java::awt::Window, ::java::awt::Shape)>("setWindowShape"), //
	};

	template<typename R = ::jfloat, typename... Args>
	static auto getWindowOpacity(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getWindowOpacity")] != -1);
		return scall<R>("getWindowOpacity", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::Shape, typename... Args>
	static auto getWindowShape(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getWindowShape")] != -1);
		return scall<R>("getWindowShape", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isTranslucencyCapable(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isTranslucencyCapable")] != -1);
		return scall<R>("isTranslucencyCapable", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isTranslucencySupported(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isTranslucencySupported")] != -1);
		return scall<R>("isTranslucencySupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isWindowOpaque(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isWindowOpaque")] != -1);
		return scall<R>("isWindowOpaque", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isWindowShapingSupported(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isWindowShapingSupported")] != -1);
		return scall<R>("isWindowShapingSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto setComponentMixingCutoutShape(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setComponentMixingCutoutShape")] != -1);
		return scall<R>("setComponentMixingCutoutShape", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto setWindowOpacity(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setWindowOpacity")] != -1);
		return scall<R>("setWindowOpacity", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto setWindowOpaque(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setWindowOpaque")] != -1);
		return scall<R>("setWindowOpaque", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto setWindowShape(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setWindowShape")] != -1);
		return scall<R>("setWindowShape", std::forward<Args>(args)...);
	}

};

#endif
