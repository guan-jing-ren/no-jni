#ifndef com_sun_imageio_plugins_png_PNGMetadata_HPP
#define com_sun_imageio_plugins_png_PNGMetadata_HPP

#include "../../../../../jfwd_decl.hpp"

class ::com::sun::imageio::plugins::png::PNGMetadata : public jObject<::com::sun::imageio::plugins::png::PNGMetadata, ::javax::imageio::metadata::IIOMetadata> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_imageio_plugins_png / "PNGMetadata";

	constexpr static Enume field_signatures{
		jField<::jint>("IHDR_bitDepth"), //
		jField<::jint>("IHDR_colorType"), //
		jField<::jint>("IHDR_compressionMethod"), //
		jField<::jint>("IHDR_filterMethod"), //
		jField<::jint>("IHDR_height"), //
		jField<::jint>("IHDR_interlaceMethod"), //
		jField<::jboolean>("IHDR_present"), //
		jField<::jint>("IHDR_width"), //
		jField<::jint>("PHYS_UNIT_METER"), //
		jField<::jint>("PHYS_UNIT_UNKNOWN"), //
		jField<::jbyte *>("PLTE_blue"), //
		jField<::jbyte *>("PLTE_green"), //
		jField<::jint *>("PLTE_order"), //
		jField<::jboolean>("PLTE_present"), //
		jField<::jbyte *>("PLTE_red"), //
		jField<::jint>("bKGD_blue"), //
		jField<::jint>("bKGD_colorType"), //
		jField<::jint>("bKGD_gray"), //
		jField<::jint>("bKGD_green"), //
		jField<::jint>("bKGD_index"), //
		jField<::jboolean>("bKGD_present"), //
		jField<::jint>("bKGD_red"), //
		jField<::jint>("cHRM_blueX"), //
		jField<::jint>("cHRM_blueY"), //
		jField<::jint>("cHRM_greenX"), //
		jField<::jint>("cHRM_greenY"), //
		jField<::jboolean>("cHRM_present"), //
		jField<::jint>("cHRM_redX"), //
		jField<::jint>("cHRM_redY"), //
		jField<::jint>("cHRM_whitePointX"), //
		jField<::jint>("cHRM_whitePointY"), //
		jField<::jint>("gAMA_gamma"), //
		jField<::jboolean>("gAMA_present"), //
		jField<::jchar *>("hIST_histogram"), //
		jField<::jboolean>("hIST_present"), //
		jField<::jbyte *>("iCCP_compressedProfile"), //
		jField<::jint>("iCCP_compressionMethod"), //
		jField<::jboolean>("iCCP_present"), //
		jField<::java::lang::String>("iCCP_profileName"), //
		jField<::java::util::ArrayList>("iTXt_compressionFlag"), //
		jField<::java::util::ArrayList>("iTXt_compressionMethod"), //
		jField<::java::util::ArrayList>("iTXt_keyword"), //
		jField<::java::util::ArrayList>("iTXt_languageTag"), //
		jField<::java::util::ArrayList>("iTXt_text"), //
		jField<::java::util::ArrayList>("iTXt_translatedKeyword"), //
		jField<::java::lang::String>("nativeMetadataFormatName"), //
		jField<::jint>("pHYs_pixelsPerUnitXAxis"), //
		jField<::jint>("pHYs_pixelsPerUnitYAxis"), //
		jField<::jboolean>("pHYs_present"), //
		jField<::jint>("pHYs_unitSpecifier"), //
		jField<::jint>("sBIT_alphaBits"), //
		jField<::jint>("sBIT_blueBits"), //
		jField<::jint>("sBIT_colorType"), //
		jField<::jint>("sBIT_grayBits"), //
		jField<::jint>("sBIT_greenBits"), //
		jField<::jboolean>("sBIT_present"), //
		jField<::jint>("sBIT_redBits"), //
		jField<::jint *>("sPLT_alpha"), //
		jField<::jint *>("sPLT_blue"), //
		jField<::jint *>("sPLT_frequency"), //
		jField<::jint *>("sPLT_green"), //
		jField<::java::lang::String>("sPLT_paletteName"), //
		jField<::jboolean>("sPLT_present"), //
		jField<::jint *>("sPLT_red"), //
		jField<::jint>("sPLT_sampleDepth"), //
		jField<::jboolean>("sRGB_present"), //
		jField<::jint>("sRGB_renderingIntent"), //
		jField<::java::util::ArrayList>("tEXt_keyword"), //
		jField<::java::util::ArrayList>("tEXt_text"), //
		jField<::jint>("tIME_day"), //
		jField<::jint>("tIME_hour"), //
		jField<::jint>("tIME_minute"), //
		jField<::jint>("tIME_month"), //
		jField<::jboolean>("tIME_present"), //
		jField<::jint>("tIME_second"), //
		jField<::jint>("tIME_year"), //
		jField<::jbyte *>("tRNS_alpha"), //
		jField<::jint>("tRNS_blue"), //
		jField<::jint>("tRNS_colorType"), //
		jField<::jint>("tRNS_gray"), //
		jField<::jint>("tRNS_green"), //
		jField<::jboolean>("tRNS_present"), //
		jField<::jint>("tRNS_red"), //
		jField<::java::util::ArrayList>("unknownChunkData"), //
		jField<::java::util::ArrayList>("unknownChunkType"), //
		jField<::java::util::ArrayList>("zTXt_compressionMethod"), //
		jField<::java::util::ArrayList>("zTXt_keyword"), //
		jField<::java::util::ArrayList>("zTXt_text"), //
	};

	template<typename F = ::jint>
	auto IHDR_bitDepth() const {
		static_assert(field_signatures[jField<F>("IHDR_bitDepth")] != -1);
		return at<F>("IHDR_bitDepth");
	}

	template<typename F = ::jint>
	auto IHDR_colorType() const {
		static_assert(field_signatures[jField<F>("IHDR_colorType")] != -1);
		return at<F>("IHDR_colorType");
	}

	template<typename F = ::jint>
	auto IHDR_compressionMethod() const {
		static_assert(field_signatures[jField<F>("IHDR_compressionMethod")] != -1);
		return at<F>("IHDR_compressionMethod");
	}

	template<typename F = ::jint>
	auto IHDR_filterMethod() const {
		static_assert(field_signatures[jField<F>("IHDR_filterMethod")] != -1);
		return at<F>("IHDR_filterMethod");
	}

	template<typename F = ::jint>
	auto IHDR_height() const {
		static_assert(field_signatures[jField<F>("IHDR_height")] != -1);
		return at<F>("IHDR_height");
	}

	template<typename F = ::jint>
	auto IHDR_interlaceMethod() const {
		static_assert(field_signatures[jField<F>("IHDR_interlaceMethod")] != -1);
		return at<F>("IHDR_interlaceMethod");
	}

	template<typename F = ::jboolean>
	auto IHDR_present() const {
		static_assert(field_signatures[jField<F>("IHDR_present")] != -1);
		return at<F>("IHDR_present");
	}

	template<typename F = ::jint>
	auto IHDR_width() const {
		static_assert(field_signatures[jField<F>("IHDR_width")] != -1);
		return at<F>("IHDR_width");
	}

	template<typename F = ::jint>
	static auto PHYS_UNIT_METER() {
		static_assert(field_signatures[jField<F>("PHYS_UNIT_METER")] != -1);
		return sat<F>("PHYS_UNIT_METER");
	}

	template<typename F = ::jint>
	static auto PHYS_UNIT_UNKNOWN() {
		static_assert(field_signatures[jField<F>("PHYS_UNIT_UNKNOWN")] != -1);
		return sat<F>("PHYS_UNIT_UNKNOWN");
	}

	template<typename F = ::jbyte *>
	auto PLTE_blue() const {
		static_assert(field_signatures[jField<F>("PLTE_blue")] != -1);
		return at<F>("PLTE_blue");
	}

	template<typename F = ::jbyte *>
	auto PLTE_green() const {
		static_assert(field_signatures[jField<F>("PLTE_green")] != -1);
		return at<F>("PLTE_green");
	}

	template<typename F = ::jint *>
	auto PLTE_order() const {
		static_assert(field_signatures[jField<F>("PLTE_order")] != -1);
		return at<F>("PLTE_order");
	}

	template<typename F = ::jboolean>
	auto PLTE_present() const {
		static_assert(field_signatures[jField<F>("PLTE_present")] != -1);
		return at<F>("PLTE_present");
	}

	template<typename F = ::jbyte *>
	auto PLTE_red() const {
		static_assert(field_signatures[jField<F>("PLTE_red")] != -1);
		return at<F>("PLTE_red");
	}

	template<typename F = ::jint>
	auto bKGD_blue() const {
		static_assert(field_signatures[jField<F>("bKGD_blue")] != -1);
		return at<F>("bKGD_blue");
	}

	template<typename F = ::jint>
	auto bKGD_colorType() const {
		static_assert(field_signatures[jField<F>("bKGD_colorType")] != -1);
		return at<F>("bKGD_colorType");
	}

	template<typename F = ::jint>
	auto bKGD_gray() const {
		static_assert(field_signatures[jField<F>("bKGD_gray")] != -1);
		return at<F>("bKGD_gray");
	}

	template<typename F = ::jint>
	auto bKGD_green() const {
		static_assert(field_signatures[jField<F>("bKGD_green")] != -1);
		return at<F>("bKGD_green");
	}

	template<typename F = ::jint>
	auto bKGD_index() const {
		static_assert(field_signatures[jField<F>("bKGD_index")] != -1);
		return at<F>("bKGD_index");
	}

	template<typename F = ::jboolean>
	auto bKGD_present() const {
		static_assert(field_signatures[jField<F>("bKGD_present")] != -1);
		return at<F>("bKGD_present");
	}

	template<typename F = ::jint>
	auto bKGD_red() const {
		static_assert(field_signatures[jField<F>("bKGD_red")] != -1);
		return at<F>("bKGD_red");
	}

	template<typename F = ::jint>
	auto cHRM_blueX() const {
		static_assert(field_signatures[jField<F>("cHRM_blueX")] != -1);
		return at<F>("cHRM_blueX");
	}

	template<typename F = ::jint>
	auto cHRM_blueY() const {
		static_assert(field_signatures[jField<F>("cHRM_blueY")] != -1);
		return at<F>("cHRM_blueY");
	}

	template<typename F = ::jint>
	auto cHRM_greenX() const {
		static_assert(field_signatures[jField<F>("cHRM_greenX")] != -1);
		return at<F>("cHRM_greenX");
	}

	template<typename F = ::jint>
	auto cHRM_greenY() const {
		static_assert(field_signatures[jField<F>("cHRM_greenY")] != -1);
		return at<F>("cHRM_greenY");
	}

	template<typename F = ::jboolean>
	auto cHRM_present() const {
		static_assert(field_signatures[jField<F>("cHRM_present")] != -1);
		return at<F>("cHRM_present");
	}

	template<typename F = ::jint>
	auto cHRM_redX() const {
		static_assert(field_signatures[jField<F>("cHRM_redX")] != -1);
		return at<F>("cHRM_redX");
	}

	template<typename F = ::jint>
	auto cHRM_redY() const {
		static_assert(field_signatures[jField<F>("cHRM_redY")] != -1);
		return at<F>("cHRM_redY");
	}

	template<typename F = ::jint>
	auto cHRM_whitePointX() const {
		static_assert(field_signatures[jField<F>("cHRM_whitePointX")] != -1);
		return at<F>("cHRM_whitePointX");
	}

	template<typename F = ::jint>
	auto cHRM_whitePointY() const {
		static_assert(field_signatures[jField<F>("cHRM_whitePointY")] != -1);
		return at<F>("cHRM_whitePointY");
	}

	template<typename F = ::jint>
	auto gAMA_gamma() const {
		static_assert(field_signatures[jField<F>("gAMA_gamma")] != -1);
		return at<F>("gAMA_gamma");
	}

	template<typename F = ::jboolean>
	auto gAMA_present() const {
		static_assert(field_signatures[jField<F>("gAMA_present")] != -1);
		return at<F>("gAMA_present");
	}

	template<typename F = ::jchar *>
	auto hIST_histogram() const {
		static_assert(field_signatures[jField<F>("hIST_histogram")] != -1);
		return at<F>("hIST_histogram");
	}

	template<typename F = ::jboolean>
	auto hIST_present() const {
		static_assert(field_signatures[jField<F>("hIST_present")] != -1);
		return at<F>("hIST_present");
	}

	template<typename F = ::jbyte *>
	auto iCCP_compressedProfile() const {
		static_assert(field_signatures[jField<F>("iCCP_compressedProfile")] != -1);
		return at<F>("iCCP_compressedProfile");
	}

	template<typename F = ::jint>
	auto iCCP_compressionMethod() const {
		static_assert(field_signatures[jField<F>("iCCP_compressionMethod")] != -1);
		return at<F>("iCCP_compressionMethod");
	}

	template<typename F = ::jboolean>
	auto iCCP_present() const {
		static_assert(field_signatures[jField<F>("iCCP_present")] != -1);
		return at<F>("iCCP_present");
	}

	template<typename F = ::java::lang::String>
	auto iCCP_profileName() const {
		static_assert(field_signatures[jField<F>("iCCP_profileName")] != -1);
		return at<F>("iCCP_profileName");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_compressionFlag() const {
		static_assert(field_signatures[jField<F>("iTXt_compressionFlag")] != -1);
		return at<F>("iTXt_compressionFlag");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_compressionMethod() const {
		static_assert(field_signatures[jField<F>("iTXt_compressionMethod")] != -1);
		return at<F>("iTXt_compressionMethod");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_keyword() const {
		static_assert(field_signatures[jField<F>("iTXt_keyword")] != -1);
		return at<F>("iTXt_keyword");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_languageTag() const {
		static_assert(field_signatures[jField<F>("iTXt_languageTag")] != -1);
		return at<F>("iTXt_languageTag");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_text() const {
		static_assert(field_signatures[jField<F>("iTXt_text")] != -1);
		return at<F>("iTXt_text");
	}

	template<typename F = ::java::util::ArrayList>
	auto iTXt_translatedKeyword() const {
		static_assert(field_signatures[jField<F>("iTXt_translatedKeyword")] != -1);
		return at<F>("iTXt_translatedKeyword");
	}

	template<typename F = ::java::lang::String>
	static auto nativeMetadataFormatName() {
		static_assert(field_signatures[jField<F>("nativeMetadataFormatName")] != -1);
		return sat<F>("nativeMetadataFormatName");
	}

	template<typename F = ::jint>
	auto pHYs_pixelsPerUnitXAxis() const {
		static_assert(field_signatures[jField<F>("pHYs_pixelsPerUnitXAxis")] != -1);
		return at<F>("pHYs_pixelsPerUnitXAxis");
	}

	template<typename F = ::jint>
	auto pHYs_pixelsPerUnitYAxis() const {
		static_assert(field_signatures[jField<F>("pHYs_pixelsPerUnitYAxis")] != -1);
		return at<F>("pHYs_pixelsPerUnitYAxis");
	}

	template<typename F = ::jboolean>
	auto pHYs_present() const {
		static_assert(field_signatures[jField<F>("pHYs_present")] != -1);
		return at<F>("pHYs_present");
	}

	template<typename F = ::jint>
	auto pHYs_unitSpecifier() const {
		static_assert(field_signatures[jField<F>("pHYs_unitSpecifier")] != -1);
		return at<F>("pHYs_unitSpecifier");
	}

	template<typename F = ::jint>
	auto sBIT_alphaBits() const {
		static_assert(field_signatures[jField<F>("sBIT_alphaBits")] != -1);
		return at<F>("sBIT_alphaBits");
	}

	template<typename F = ::jint>
	auto sBIT_blueBits() const {
		static_assert(field_signatures[jField<F>("sBIT_blueBits")] != -1);
		return at<F>("sBIT_blueBits");
	}

	template<typename F = ::jint>
	auto sBIT_colorType() const {
		static_assert(field_signatures[jField<F>("sBIT_colorType")] != -1);
		return at<F>("sBIT_colorType");
	}

	template<typename F = ::jint>
	auto sBIT_grayBits() const {
		static_assert(field_signatures[jField<F>("sBIT_grayBits")] != -1);
		return at<F>("sBIT_grayBits");
	}

	template<typename F = ::jint>
	auto sBIT_greenBits() const {
		static_assert(field_signatures[jField<F>("sBIT_greenBits")] != -1);
		return at<F>("sBIT_greenBits");
	}

	template<typename F = ::jboolean>
	auto sBIT_present() const {
		static_assert(field_signatures[jField<F>("sBIT_present")] != -1);
		return at<F>("sBIT_present");
	}

	template<typename F = ::jint>
	auto sBIT_redBits() const {
		static_assert(field_signatures[jField<F>("sBIT_redBits")] != -1);
		return at<F>("sBIT_redBits");
	}

	template<typename F = ::jint *>
	auto sPLT_alpha() const {
		static_assert(field_signatures[jField<F>("sPLT_alpha")] != -1);
		return at<F>("sPLT_alpha");
	}

	template<typename F = ::jint *>
	auto sPLT_blue() const {
		static_assert(field_signatures[jField<F>("sPLT_blue")] != -1);
		return at<F>("sPLT_blue");
	}

	template<typename F = ::jint *>
	auto sPLT_frequency() const {
		static_assert(field_signatures[jField<F>("sPLT_frequency")] != -1);
		return at<F>("sPLT_frequency");
	}

	template<typename F = ::jint *>
	auto sPLT_green() const {
		static_assert(field_signatures[jField<F>("sPLT_green")] != -1);
		return at<F>("sPLT_green");
	}

	template<typename F = ::java::lang::String>
	auto sPLT_paletteName() const {
		static_assert(field_signatures[jField<F>("sPLT_paletteName")] != -1);
		return at<F>("sPLT_paletteName");
	}

	template<typename F = ::jboolean>
	auto sPLT_present() const {
		static_assert(field_signatures[jField<F>("sPLT_present")] != -1);
		return at<F>("sPLT_present");
	}

	template<typename F = ::jint *>
	auto sPLT_red() const {
		static_assert(field_signatures[jField<F>("sPLT_red")] != -1);
		return at<F>("sPLT_red");
	}

	template<typename F = ::jint>
	auto sPLT_sampleDepth() const {
		static_assert(field_signatures[jField<F>("sPLT_sampleDepth")] != -1);
		return at<F>("sPLT_sampleDepth");
	}

	template<typename F = ::jboolean>
	auto sRGB_present() const {
		static_assert(field_signatures[jField<F>("sRGB_present")] != -1);
		return at<F>("sRGB_present");
	}

	template<typename F = ::jint>
	auto sRGB_renderingIntent() const {
		static_assert(field_signatures[jField<F>("sRGB_renderingIntent")] != -1);
		return at<F>("sRGB_renderingIntent");
	}

	template<typename F = ::java::util::ArrayList>
	auto tEXt_keyword() const {
		static_assert(field_signatures[jField<F>("tEXt_keyword")] != -1);
		return at<F>("tEXt_keyword");
	}

	template<typename F = ::java::util::ArrayList>
	auto tEXt_text() const {
		static_assert(field_signatures[jField<F>("tEXt_text")] != -1);
		return at<F>("tEXt_text");
	}

	template<typename F = ::jint>
	auto tIME_day() const {
		static_assert(field_signatures[jField<F>("tIME_day")] != -1);
		return at<F>("tIME_day");
	}

	template<typename F = ::jint>
	auto tIME_hour() const {
		static_assert(field_signatures[jField<F>("tIME_hour")] != -1);
		return at<F>("tIME_hour");
	}

	template<typename F = ::jint>
	auto tIME_minute() const {
		static_assert(field_signatures[jField<F>("tIME_minute")] != -1);
		return at<F>("tIME_minute");
	}

	template<typename F = ::jint>
	auto tIME_month() const {
		static_assert(field_signatures[jField<F>("tIME_month")] != -1);
		return at<F>("tIME_month");
	}

	template<typename F = ::jboolean>
	auto tIME_present() const {
		static_assert(field_signatures[jField<F>("tIME_present")] != -1);
		return at<F>("tIME_present");
	}

	template<typename F = ::jint>
	auto tIME_second() const {
		static_assert(field_signatures[jField<F>("tIME_second")] != -1);
		return at<F>("tIME_second");
	}

	template<typename F = ::jint>
	auto tIME_year() const {
		static_assert(field_signatures[jField<F>("tIME_year")] != -1);
		return at<F>("tIME_year");
	}

	template<typename F = ::jbyte *>
	auto tRNS_alpha() const {
		static_assert(field_signatures[jField<F>("tRNS_alpha")] != -1);
		return at<F>("tRNS_alpha");
	}

	template<typename F = ::jint>
	auto tRNS_blue() const {
		static_assert(field_signatures[jField<F>("tRNS_blue")] != -1);
		return at<F>("tRNS_blue");
	}

	template<typename F = ::jint>
	auto tRNS_colorType() const {
		static_assert(field_signatures[jField<F>("tRNS_colorType")] != -1);
		return at<F>("tRNS_colorType");
	}

	template<typename F = ::jint>
	auto tRNS_gray() const {
		static_assert(field_signatures[jField<F>("tRNS_gray")] != -1);
		return at<F>("tRNS_gray");
	}

	template<typename F = ::jint>
	auto tRNS_green() const {
		static_assert(field_signatures[jField<F>("tRNS_green")] != -1);
		return at<F>("tRNS_green");
	}

	template<typename F = ::jboolean>
	auto tRNS_present() const {
		static_assert(field_signatures[jField<F>("tRNS_present")] != -1);
		return at<F>("tRNS_present");
	}

	template<typename F = ::jint>
	auto tRNS_red() const {
		static_assert(field_signatures[jField<F>("tRNS_red")] != -1);
		return at<F>("tRNS_red");
	}

	template<typename F = ::java::util::ArrayList>
	auto unknownChunkData() const {
		static_assert(field_signatures[jField<F>("unknownChunkData")] != -1);
		return at<F>("unknownChunkData");
	}

	template<typename F = ::java::util::ArrayList>
	auto unknownChunkType() const {
		static_assert(field_signatures[jField<F>("unknownChunkType")] != -1);
		return at<F>("unknownChunkType");
	}

	template<typename F = ::java::util::ArrayList>
	auto zTXt_compressionMethod() const {
		static_assert(field_signatures[jField<F>("zTXt_compressionMethod")] != -1);
		return at<F>("zTXt_compressionMethod");
	}

	template<typename F = ::java::util::ArrayList>
	auto zTXt_keyword() const {
		static_assert(field_signatures[jField<F>("zTXt_keyword")] != -1);
		return at<F>("zTXt_keyword");
	}

	template<typename F = ::java::util::ArrayList>
	auto zTXt_text() const {
		static_assert(field_signatures[jField<F>("zTXt_text")] != -1);
		return at<F>("zTXt_text");
	}

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jConstructor<::jvoid(::javax::imageio::metadata::IIOMetadata)>(), //
		jMethod<::java::lang::Object()>("clone"), //
		jMethod<::org::w3c::dom::Node(::java::lang::String)>("getAsTree"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardChromaNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardCompressionNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardDataNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardDimensionNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardDocumentNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardTextNode"), //
		jMethod<::javax::imageio::metadata::IIOMetadataNode()>("getStandardTransparencyNode"), //
		jMethod<::jvoid(::javax::imageio::ImageTypeSpecifier, ::jint)>("initialize"), //
		jMethod<::jboolean()>("isReadOnly"), //
		jMethod<::jvoid(::java::lang::String, ::org::w3c::dom::Node)>("mergeTree"), //
		jMethod<::jvoid()>("reset"), //
	};

	template<typename R = ::java::lang::Object, typename... Args>
	auto clone(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("clone")] != -1);
		return call<R>("clone", std::forward<Args>(args)...);
	}

	template<typename R = ::org::w3c::dom::Node, typename... Args>
	auto getAsTree(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAsTree")] != -1);
		return call<R>("getAsTree", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardChromaNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardChromaNode")] != -1);
		return call<R>("getStandardChromaNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardCompressionNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardCompressionNode")] != -1);
		return call<R>("getStandardCompressionNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardDataNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardDataNode")] != -1);
		return call<R>("getStandardDataNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardDimensionNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardDimensionNode")] != -1);
		return call<R>("getStandardDimensionNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardDocumentNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardDocumentNode")] != -1);
		return call<R>("getStandardDocumentNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardTextNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardTextNode")] != -1);
		return call<R>("getStandardTextNode", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::imageio::metadata::IIOMetadataNode, typename... Args>
	auto getStandardTransparencyNode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getStandardTransparencyNode")] != -1);
		return call<R>("getStandardTransparencyNode", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto initialize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("initialize")] != -1);
		return call<R>("initialize", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isReadOnly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isReadOnly")] != -1);
		return call<R>("isReadOnly", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto mergeTree(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("mergeTree")] != -1);
		return call<R>("mergeTree", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto reset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reset")] != -1);
		return call<R>("reset", std::forward<Args>(args)...);
	}

};

#endif
