#ifndef com_sun_jndi_ldap_BerDecoder_HPP
#define com_sun_jndi_ldap_BerDecoder_HPP

#include "../../../../jfwd_decl.hpp"

class ::com::sun::jndi::ldap::BerDecoder : public jObject<::com::sun::jndi::ldap::BerDecoder, ::com::sun::jndi::ldap::Ber> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_jndi_ldap / "BerDecoder";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid(::jbyte *, ::jint, ::jint)>(), //
		jMethod<::jint()>("bytesLeft"), //
		jMethod<::jint()>("getParsePosition"), //
		jMethod<::jboolean()>("parseBoolean"), //
		jMethod<::jint()>("parseByte"), //
		jMethod<::jint()>("parseEnumeration"), //
		jMethod<::jint()>("parseInt"), //
		jMethod<::jint()>("parseLength"), //
		jMethod<::jbyte *(::jint, ::jint *)>("parseOctetString"), //
		jMethod<::jint(::jint *)>("parseSeq"), //
		jMethod<::java::lang::String(::jboolean)>("parseString"), //
		jMethod<::java::lang::String(::jint, ::jboolean, ::jint *)>("parseStringWithTag"), //
		jMethod<::jint()>("peekByte"), //
		jMethod<::jvoid()>("reset"), //
	};

	template<typename R = ::jint, typename... Args>
	auto bytesLeft(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("bytesLeft")] != -1);
		return call<R>("bytesLeft", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getParsePosition(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getParsePosition")] != -1);
		return call<R>("getParsePosition", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto parseBoolean(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseBoolean")] != -1);
		return call<R>("parseBoolean", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto parseByte(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseByte")] != -1);
		return call<R>("parseByte", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto parseEnumeration(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseEnumeration")] != -1);
		return call<R>("parseEnumeration", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto parseInt(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseInt")] != -1);
		return call<R>("parseInt", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto parseLength(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseLength")] != -1);
		return call<R>("parseLength", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	auto parseOctetString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseOctetString")] != -1);
		return call<R>("parseOctetString", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto parseSeq(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseSeq")] != -1);
		return call<R>("parseSeq", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto parseString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseString")] != -1);
		return call<R>("parseString", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto parseStringWithTag(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parseStringWithTag")] != -1);
		return call<R>("parseStringWithTag", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto peekByte(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("peekByte")] != -1);
		return call<R>("peekByte", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto reset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reset")] != -1);
		return call<R>("reset", std::forward<Args>(args)...);
	}

};

#endif
