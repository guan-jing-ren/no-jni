#ifndef com_sun_jndi_ldap_Ber_HPP
#define com_sun_jndi_ldap_Ber_HPP

#include "../../../../jfwd_decl.hpp"

class ::com::sun::jndi::ldap::Ber : public jObject<::com::sun::jndi::ldap::Ber, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::com_sun_jndi_ldap / "Ber";

	constexpr static Enume field_signatures{
		jField<::jint>("ASN_APPLICATION"), //
		jField<::jint>("ASN_BIT_STRING"), //
		jField<::jint>("ASN_BOOLEAN"), //
		jField<::jint>("ASN_CONSTRUCTOR"), //
		jField<::jint>("ASN_CONTEXT"), //
		jField<::jint>("ASN_ENUMERATED"), //
		jField<::jint>("ASN_INTEGER"), //
		jField<::jint>("ASN_NULL"), //
		jField<::jint>("ASN_OBJECT_ID"), //
		jField<::jint>("ASN_OCTET_STR"), //
		jField<::jint>("ASN_PRIMITIVE"), //
		jField<::jint>("ASN_PRIVATE"), //
		jField<::jint>("ASN_SEQUENCE"), //
		jField<::jint>("ASN_SET"), //
		jField<::jint>("ASN_SIMPLE_STRING"), //
		jField<::jint>("ASN_UNIVERSAL"), //
	};

	template<typename F = ::jint>
	static auto ASN_APPLICATION() {
		static_assert(field_signatures[jField<F>("ASN_APPLICATION")] != -1);
		return sat<F>("ASN_APPLICATION");
	}

	template<typename F = ::jint>
	static auto ASN_BIT_STRING() {
		static_assert(field_signatures[jField<F>("ASN_BIT_STRING")] != -1);
		return sat<F>("ASN_BIT_STRING");
	}

	template<typename F = ::jint>
	static auto ASN_BOOLEAN() {
		static_assert(field_signatures[jField<F>("ASN_BOOLEAN")] != -1);
		return sat<F>("ASN_BOOLEAN");
	}

	template<typename F = ::jint>
	static auto ASN_CONSTRUCTOR() {
		static_assert(field_signatures[jField<F>("ASN_CONSTRUCTOR")] != -1);
		return sat<F>("ASN_CONSTRUCTOR");
	}

	template<typename F = ::jint>
	static auto ASN_CONTEXT() {
		static_assert(field_signatures[jField<F>("ASN_CONTEXT")] != -1);
		return sat<F>("ASN_CONTEXT");
	}

	template<typename F = ::jint>
	static auto ASN_ENUMERATED() {
		static_assert(field_signatures[jField<F>("ASN_ENUMERATED")] != -1);
		return sat<F>("ASN_ENUMERATED");
	}

	template<typename F = ::jint>
	static auto ASN_INTEGER() {
		static_assert(field_signatures[jField<F>("ASN_INTEGER")] != -1);
		return sat<F>("ASN_INTEGER");
	}

	template<typename F = ::jint>
	static auto ASN_NULL() {
		static_assert(field_signatures[jField<F>("ASN_NULL")] != -1);
		return sat<F>("ASN_NULL");
	}

	template<typename F = ::jint>
	static auto ASN_OBJECT_ID() {
		static_assert(field_signatures[jField<F>("ASN_OBJECT_ID")] != -1);
		return sat<F>("ASN_OBJECT_ID");
	}

	template<typename F = ::jint>
	static auto ASN_OCTET_STR() {
		static_assert(field_signatures[jField<F>("ASN_OCTET_STR")] != -1);
		return sat<F>("ASN_OCTET_STR");
	}

	template<typename F = ::jint>
	static auto ASN_PRIMITIVE() {
		static_assert(field_signatures[jField<F>("ASN_PRIMITIVE")] != -1);
		return sat<F>("ASN_PRIMITIVE");
	}

	template<typename F = ::jint>
	static auto ASN_PRIVATE() {
		static_assert(field_signatures[jField<F>("ASN_PRIVATE")] != -1);
		return sat<F>("ASN_PRIVATE");
	}

	template<typename F = ::jint>
	static auto ASN_SEQUENCE() {
		static_assert(field_signatures[jField<F>("ASN_SEQUENCE")] != -1);
		return sat<F>("ASN_SEQUENCE");
	}

	template<typename F = ::jint>
	static auto ASN_SET() {
		static_assert(field_signatures[jField<F>("ASN_SET")] != -1);
		return sat<F>("ASN_SET");
	}

	template<typename F = ::jint>
	static auto ASN_SIMPLE_STRING() {
		static_assert(field_signatures[jField<F>("ASN_SIMPLE_STRING")] != -1);
		return sat<F>("ASN_SIMPLE_STRING");
	}

	template<typename F = ::jint>
	static auto ASN_UNIVERSAL() {
		static_assert(field_signatures[jField<F>("ASN_UNIVERSAL")] != -1);
		return sat<F>("ASN_UNIVERSAL");
	}

	constexpr static Enume method_signatures{
		jMethod<::jvoid(::java::io::OutputStream, ::java::lang::String, ::jbyte *, ::jint, ::jint)>("dumpBER"), //
	};

	template<typename R = ::jvoid, typename... Args>
	static auto dumpBER(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("dumpBER")] != -1);
		return scall<R>("dumpBER", std::forward<Args>(args)...);
	}

};

#endif
