#ifndef javax_sound_midi_Synthesizer_HPP
#define javax_sound_midi_Synthesizer_HPP

#include "../../../jfwd_decl.hpp"

class ::javax::sound::midi::Synthesizer : public jObject<::javax::sound::midi::Synthesizer, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_sound_midi / "Synthesizer";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::javax::sound::midi::Instrument *()>("getAvailableInstruments"), //
		jMethod<::javax::sound::midi::MidiChannel *()>("getChannels"), //
		jMethod<::javax::sound::midi::Soundbank()>("getDefaultSoundbank"), //
		jMethod<::jlong()>("getLatency"), //
		jMethod<::javax::sound::midi::Instrument *()>("getLoadedInstruments"), //
		jMethod<::jint()>("getMaxPolyphony"), //
		jMethod<::javax::sound::midi::VoiceStatus *()>("getVoiceStatus"), //
		jMethod<::jboolean(::javax::sound::midi::Soundbank)>("isSoundbankSupported"), //
		jMethod<::jboolean(::javax::sound::midi::Soundbank)>("loadAllInstruments"), //
		jMethod<::jboolean(::javax::sound::midi::Instrument)>("loadInstrument"), //
		jMethod<::jboolean(::javax::sound::midi::Soundbank, ::javax::sound::midi::Patch *)>("loadInstruments"), //
		jMethod<::jboolean(::javax::sound::midi::Instrument, ::javax::sound::midi::Instrument)>("remapInstrument"), //
		jMethod<::jvoid(::javax::sound::midi::Soundbank)>("unloadAllInstruments"), //
		jMethod<::jvoid(::javax::sound::midi::Instrument)>("unloadInstrument"), //
		jMethod<::jvoid(::javax::sound::midi::Soundbank, ::javax::sound::midi::Patch *)>("unloadInstruments"), //
	};

	template<typename R = ::javax::sound::midi::Instrument *, typename... Args>
	auto getAvailableInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAvailableInstruments")] != -1);
		return call<R>("getAvailableInstruments", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::sound::midi::MidiChannel *, typename... Args>
	auto getChannels(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getChannels")] != -1);
		return call<R>("getChannels", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::sound::midi::Soundbank, typename... Args>
	auto getDefaultSoundbank(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDefaultSoundbank")] != -1);
		return call<R>("getDefaultSoundbank", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getLatency(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getLatency")] != -1);
		return call<R>("getLatency", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::sound::midi::Instrument *, typename... Args>
	auto getLoadedInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getLoadedInstruments")] != -1);
		return call<R>("getLoadedInstruments", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getMaxPolyphony(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getMaxPolyphony")] != -1);
		return call<R>("getMaxPolyphony", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::sound::midi::VoiceStatus *, typename... Args>
	auto getVoiceStatus(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getVoiceStatus")] != -1);
		return call<R>("getVoiceStatus", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSoundbankSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSoundbankSupported")] != -1);
		return call<R>("isSoundbankSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto loadAllInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("loadAllInstruments")] != -1);
		return call<R>("loadAllInstruments", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto loadInstrument(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("loadInstrument")] != -1);
		return call<R>("loadInstrument", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto loadInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("loadInstruments")] != -1);
		return call<R>("loadInstruments", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto remapInstrument(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("remapInstrument")] != -1);
		return call<R>("remapInstrument", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unloadAllInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("unloadAllInstruments")] != -1);
		return call<R>("unloadAllInstruments", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unloadInstrument(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("unloadInstrument")] != -1);
		return call<R>("unloadInstrument", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unloadInstruments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("unloadInstruments")] != -1);
		return call<R>("unloadInstruments", std::forward<Args>(args)...);
	}

};

#endif
