#ifndef javax_lang_model_util_Types_HPP
#define javax_lang_model_util_Types_HPP

#include "../../../../jfwd_decl.hpp"

class ::javax::lang::model::util::Types : public jObject<::javax::lang::model::util::Types, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_lang_model_util / "Types";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::javax::lang::model::element::Element(::javax::lang::model::type::TypeMirror)>("asElement"), //
		jMethod<::javax::lang::model::type::TypeMirror(::javax::lang::model::type::DeclaredType, ::javax::lang::model::element::Element)>("asMemberOf"), //
		jMethod<::javax::lang::model::element::TypeElement(::javax::lang::model::type::PrimitiveType)>("boxedClass"), //
		jMethod<::javax::lang::model::type::TypeMirror(::javax::lang::model::type::TypeMirror)>("capture"), //
		jMethod<::jboolean(::javax::lang::model::type::TypeMirror, ::javax::lang::model::type::TypeMirror)>("contains"), //
		jMethod<::java::util::List(::javax::lang::model::type::TypeMirror)>("directSupertypes"), //
		jMethod<::javax::lang::model::type::TypeMirror(::javax::lang::model::type::TypeMirror)>("erasure"), //
		jMethod<::javax::lang::model::type::ArrayType(::javax::lang::model::type::TypeMirror)>("getArrayType"), //
		jMethod<::javax::lang::model::type::DeclaredType(::javax::lang::model::element::TypeElement, ::javax::lang::model::type::TypeMirror *)>("getDeclaredType"), //
		jMethod<::javax::lang::model::type::DeclaredType(::javax::lang::model::type::DeclaredType, ::javax::lang::model::element::TypeElement, ::javax::lang::model::type::TypeMirror *)>("getDeclaredType"), //
		jMethod<::javax::lang::model::type::NoType(::javax::lang::model::type::TypeKind)>("getNoType"), //
		jMethod<::javax::lang::model::type::NullType()>("getNullType"), //
		jMethod<::javax::lang::model::type::PrimitiveType(::javax::lang::model::type::TypeKind)>("getPrimitiveType"), //
		jMethod<::javax::lang::model::type::WildcardType(::javax::lang::model::type::TypeMirror, ::javax::lang::model::type::TypeMirror)>("getWildcardType"), //
		jMethod<::jboolean(::javax::lang::model::type::TypeMirror, ::javax::lang::model::type::TypeMirror)>("isAssignable"), //
		jMethod<::jboolean(::javax::lang::model::type::TypeMirror, ::javax::lang::model::type::TypeMirror)>("isSameType"), //
		jMethod<::jboolean(::javax::lang::model::type::ExecutableType, ::javax::lang::model::type::ExecutableType)>("isSubsignature"), //
		jMethod<::jboolean(::javax::lang::model::type::TypeMirror, ::javax::lang::model::type::TypeMirror)>("isSubtype"), //
		jMethod<::javax::lang::model::type::PrimitiveType(::javax::lang::model::type::TypeMirror)>("unboxedType"), //
	};

	template<typename R = ::javax::lang::model::element::Element, typename... Args>
	auto asElement(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("asElement")] != -1);
		return call<R>("asElement", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::TypeMirror, typename... Args>
	auto asMemberOf(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("asMemberOf")] != -1);
		return call<R>("asMemberOf", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::element::TypeElement, typename... Args>
	auto boxedClass(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("boxedClass")] != -1);
		return call<R>("boxedClass", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::TypeMirror, typename... Args>
	auto capture(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("capture")] != -1);
		return call<R>("capture", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto contains(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("contains")] != -1);
		return call<R>("contains", forward<Args>(args)...);
	}

	template<typename R = ::java::util::List, typename... Args>
	auto directSupertypes(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("directSupertypes")] != -1);
		return call<R>("directSupertypes", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::TypeMirror, typename... Args>
	auto erasure(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("erasure")] != -1);
		return call<R>("erasure", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::ArrayType, typename... Args>
	auto getArrayType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getArrayType")] != -1);
		return call<R>("getArrayType", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::DeclaredType, typename... Args>
	auto getDeclaredType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getDeclaredType")] != -1);
		return call<R>("getDeclaredType", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::NoType, typename... Args>
	auto getNoType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getNoType")] != -1);
		return call<R>("getNoType", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::NullType, typename... Args>
	auto getNullType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getNullType")] != -1);
		return call<R>("getNullType", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::PrimitiveType, typename... Args>
	auto getPrimitiveType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getPrimitiveType")] != -1);
		return call<R>("getPrimitiveType", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::WildcardType, typename... Args>
	auto getWildcardType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getWildcardType")] != -1);
		return call<R>("getWildcardType", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isAssignable(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isAssignable")] != -1);
		return call<R>("isAssignable", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSameType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isSameType")] != -1);
		return call<R>("isSameType", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSubsignature(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isSubsignature")] != -1);
		return call<R>("isSubsignature", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSubtype(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isSubtype")] != -1);
		return call<R>("isSubtype", forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::PrimitiveType, typename... Args>
	auto unboxedType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("unboxedType")] != -1);
		return call<R>("unboxedType", forward<Args>(args)...);
	}

};

#endif
