#ifndef javax_lang_model_type_TypeKind_HPP
#define javax_lang_model_type_TypeKind_HPP

#include "../../../../jfwd_decl.hpp"

class ::javax::lang::model::type::TypeKind : public jObject<::javax::lang::model::type::TypeKind, ::java::lang::Enum> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_lang_model_type / "TypeKind";

	constexpr static Enume field_signatures{
		jField<::javax::lang::model::type::TypeKind>("ARRAY"), //
		jField<::javax::lang::model::type::TypeKind>("BOOLEAN"), //
		jField<::javax::lang::model::type::TypeKind>("BYTE"), //
		jField<::javax::lang::model::type::TypeKind>("CHAR"), //
		jField<::javax::lang::model::type::TypeKind>("DECLARED"), //
		jField<::javax::lang::model::type::TypeKind>("DOUBLE"), //
		jField<::javax::lang::model::type::TypeKind>("ERROR"), //
		jField<::javax::lang::model::type::TypeKind>("EXECUTABLE"), //
		jField<::javax::lang::model::type::TypeKind>("FLOAT"), //
		jField<::javax::lang::model::type::TypeKind>("INT"), //
		jField<::javax::lang::model::type::TypeKind>("INTERSECTION"), //
		jField<::javax::lang::model::type::TypeKind>("LONG"), //
		jField<::javax::lang::model::type::TypeKind>("NONE"), //
		jField<::javax::lang::model::type::TypeKind>("NULL"), //
		jField<::javax::lang::model::type::TypeKind>("OTHER"), //
		jField<::javax::lang::model::type::TypeKind>("PACKAGE"), //
		jField<::javax::lang::model::type::TypeKind>("SHORT"), //
		jField<::javax::lang::model::type::TypeKind>("TYPEVAR"), //
		jField<::javax::lang::model::type::TypeKind>("UNION"), //
		jField<::javax::lang::model::type::TypeKind>("VOID"), //
		jField<::javax::lang::model::type::TypeKind>("WILDCARD"), //
	};

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto ARRAY() {
		static_assert(field_signatures[jField<F>("ARRAY")] != -1);
		return sat<F>("ARRAY");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto BOOLEAN() {
		static_assert(field_signatures[jField<F>("BOOLEAN")] != -1);
		return sat<F>("BOOLEAN");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto BYTE() {
		static_assert(field_signatures[jField<F>("BYTE")] != -1);
		return sat<F>("BYTE");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto CHAR() {
		static_assert(field_signatures[jField<F>("CHAR")] != -1);
		return sat<F>("CHAR");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto DECLARED() {
		static_assert(field_signatures[jField<F>("DECLARED")] != -1);
		return sat<F>("DECLARED");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto DOUBLE() {
		static_assert(field_signatures[jField<F>("DOUBLE")] != -1);
		return sat<F>("DOUBLE");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto ERROR() {
		static_assert(field_signatures[jField<F>("ERROR")] != -1);
		return sat<F>("ERROR");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto EXECUTABLE() {
		static_assert(field_signatures[jField<F>("EXECUTABLE")] != -1);
		return sat<F>("EXECUTABLE");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto FLOAT() {
		static_assert(field_signatures[jField<F>("FLOAT")] != -1);
		return sat<F>("FLOAT");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto INT() {
		static_assert(field_signatures[jField<F>("INT")] != -1);
		return sat<F>("INT");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto INTERSECTION() {
		static_assert(field_signatures[jField<F>("INTERSECTION")] != -1);
		return sat<F>("INTERSECTION");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto LONG() {
		static_assert(field_signatures[jField<F>("LONG")] != -1);
		return sat<F>("LONG");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto NONE() {
		static_assert(field_signatures[jField<F>("NONE")] != -1);
		return sat<F>("NONE");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto NULL_() {
		static_assert(field_signatures[jField<F>("NULL")] != -1);
		return sat<F>("NULL");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto OTHER() {
		static_assert(field_signatures[jField<F>("OTHER")] != -1);
		return sat<F>("OTHER");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto PACKAGE() {
		static_assert(field_signatures[jField<F>("PACKAGE")] != -1);
		return sat<F>("PACKAGE");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto SHORT() {
		static_assert(field_signatures[jField<F>("SHORT")] != -1);
		return sat<F>("SHORT");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto TYPEVAR() {
		static_assert(field_signatures[jField<F>("TYPEVAR")] != -1);
		return sat<F>("TYPEVAR");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto UNION() {
		static_assert(field_signatures[jField<F>("UNION")] != -1);
		return sat<F>("UNION");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto VOID() {
		static_assert(field_signatures[jField<F>("VOID")] != -1);
		return sat<F>("VOID");
	}

	template<typename F = ::javax::lang::model::type::TypeKind>
	static auto WILDCARD() {
		static_assert(field_signatures[jField<F>("WILDCARD")] != -1);
		return sat<F>("WILDCARD");
	}

	constexpr static Enume method_signatures{
		jMethod<::jboolean()>("isPrimitive"), //
		jMethod<::javax::lang::model::type::TypeKind(::java::lang::String)>("valueOf"), //
		jMethod<::javax::lang::model::type::TypeKind *()>("values"), //
	};

	template<typename R = ::jboolean, typename... Args>
	auto isPrimitive(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isPrimitive")] != -1);
		return call<R>("isPrimitive", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::TypeKind, typename... Args>
	static auto valueOf(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("valueOf")] != -1);
		return scall<R>("valueOf", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::lang::model::type::TypeKind *, typename... Args>
	static auto values(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("values")] != -1);
		return scall<R>("values", std::forward<Args>(args)...);
	}

};

#endif
