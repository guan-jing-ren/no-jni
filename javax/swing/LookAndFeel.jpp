#ifndef javax_swing_LookAndFeel_HPP
#define javax_swing_LookAndFeel_HPP

#include "../../jfwd_decl.hpp"

class ::javax::swing::LookAndFeel : public jObject<::javax::swing::LookAndFeel, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_swing / "LookAndFeel";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jMethod<::javax::swing::UIDefaults()>("getDefaults"), //
		jMethod<::java::lang::String()>("getDescription"), //
		jMethod<::java::lang::Object(::java::lang::String, ::java::lang::Object)>("getDesktopPropertyValue"), //
		jMethod<::javax::swing::Icon(::javax::swing::JComponent, ::javax::swing::Icon)>("getDisabledIcon"), //
		jMethod<::javax::swing::Icon(::javax::swing::JComponent, ::javax::swing::Icon)>("getDisabledSelectedIcon"), //
		jMethod<::java::lang::String()>("getID"), //
		jMethod<::javax::swing::LayoutStyle()>("getLayoutStyle"), //
		jMethod<::java::lang::String()>("getName"), //
		jMethod<::jboolean()>("getSupportsWindowDecorations"), //
		jMethod<::jvoid()>("initialize"), //
		jMethod<::jvoid(::javax::swing::JComponent, ::java::lang::String)>("installBorder"), //
		jMethod<::jvoid(::javax::swing::JComponent, ::java::lang::String, ::java::lang::String)>("installColors"), //
		jMethod<::jvoid(::javax::swing::JComponent, ::java::lang::String, ::java::lang::String, ::java::lang::String)>("installColorsAndFont"), //
		jMethod<::jvoid(::javax::swing::JComponent, ::java::lang::String, ::java::lang::Object)>("installProperty"), //
		jMethod<::jboolean()>("isNativeLookAndFeel"), //
		jMethod<::jboolean()>("isSupportedLookAndFeel"), //
		jMethod<::jvoid(::javax::swing::InputMap, ::java::lang::Object *)>("loadKeyBindings"), //
		jMethod<::javax::swing::ComponentInputMap(::javax::swing::JComponent, ::java::lang::Object *)>("makeComponentInputMap"), //
		jMethod<::java::lang::Object(::java::lang::Class, ::java::lang::String)>("makeIcon"), //
		jMethod<::javax::swing::InputMap(::java::lang::Object *)>("makeInputMap"), //
		jMethod<::javax::swing::text::JTextComponent$KeyBinding *(::java::lang::Object *)>("makeKeyBindings"), //
		jMethod<::jvoid(::java::awt::Component)>("provideErrorFeedback"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::jvoid()>("uninitialize"), //
		jMethod<::jvoid(::javax::swing::JComponent)>("uninstallBorder"), //
	};

	template<typename R = ::javax::swing::UIDefaults, typename... Args>
	auto getDefaults(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDefaults")] != -1);
		return call<R>("getDefaults", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getDescription(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDescription")] != -1);
		return call<R>("getDescription", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	static auto getDesktopPropertyValue(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDesktopPropertyValue")] != -1);
		return scall<R>("getDesktopPropertyValue", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::Icon, typename... Args>
	auto getDisabledIcon(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDisabledIcon")] != -1);
		return call<R>("getDisabledIcon", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::Icon, typename... Args>
	auto getDisabledSelectedIcon(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDisabledSelectedIcon")] != -1);
		return call<R>("getDisabledSelectedIcon", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getID(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getID")] != -1);
		return call<R>("getID", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::LayoutStyle, typename... Args>
	auto getLayoutStyle(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getLayoutStyle")] != -1);
		return call<R>("getLayoutStyle", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getName")] != -1);
		return call<R>("getName", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto getSupportsWindowDecorations(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getSupportsWindowDecorations")] != -1);
		return call<R>("getSupportsWindowDecorations", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto initialize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("initialize")] != -1);
		return call<R>("initialize", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto installBorder(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("installBorder")] != -1);
		return scall<R>("installBorder", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto installColors(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("installColors")] != -1);
		return scall<R>("installColors", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto installColorsAndFont(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("installColorsAndFont")] != -1);
		return scall<R>("installColorsAndFont", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto installProperty(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("installProperty")] != -1);
		return scall<R>("installProperty", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isNativeLookAndFeel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isNativeLookAndFeel")] != -1);
		return call<R>("isNativeLookAndFeel", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSupportedLookAndFeel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSupportedLookAndFeel")] != -1);
		return call<R>("isSupportedLookAndFeel", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto loadKeyBindings(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("loadKeyBindings")] != -1);
		return scall<R>("loadKeyBindings", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::ComponentInputMap, typename... Args>
	static auto makeComponentInputMap(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("makeComponentInputMap")] != -1);
		return scall<R>("makeComponentInputMap", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	static auto makeIcon(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("makeIcon")] != -1);
		return scall<R>("makeIcon", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::InputMap, typename... Args>
	static auto makeInputMap(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("makeInputMap")] != -1);
		return scall<R>("makeInputMap", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::text::JTextComponent$KeyBinding *, typename... Args>
	static auto makeKeyBindings(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("makeKeyBindings")] != -1);
		return scall<R>("makeKeyBindings", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto provideErrorFeedback(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("provideErrorFeedback")] != -1);
		return call<R>("provideErrorFeedback", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto uninitialize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("uninitialize")] != -1);
		return call<R>("uninitialize", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto uninstallBorder(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("uninstallBorder")] != -1);
		return scall<R>("uninstallBorder", std::forward<Args>(args)...);
	}

};

#endif
