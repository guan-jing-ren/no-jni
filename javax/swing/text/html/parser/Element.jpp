#ifndef javax_swing_text_html_parser_Element_HPP
#define javax_swing_text_html_parser_Element_HPP

#include "../../../../../jfwd_decl.hpp"

class ::javax::swing::text::html::parser::Element : public jObject<::javax::swing::text::html::parser::Element, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_swing_text_html_parser / "Element";

	constexpr static Enume field_signatures{
		jField<::javax::swing::text::html::parser::AttributeList>("atts"), //
		jField<::javax::swing::text::html::parser::ContentModel>("content"), //
		jField<::java::lang::Object>("data"), //
		jField<::java::util::BitSet>("exclusions"), //
		jField<::java::util::BitSet>("inclusions"), //
		jField<::jint>("index"), //
		jField<::java::lang::String>("name"), //
		jField<::jboolean>("oEnd"), //
		jField<::jboolean>("oStart"), //
		jField<::jint>("type"), //
	};

	template<typename F = ::javax::swing::text::html::parser::AttributeList>
	auto atts() const {
		static_assert(field_signatures[jField<F>("atts")] != -1);
		return at<F>("atts");
	}

	template<typename F = ::javax::swing::text::html::parser::ContentModel>
	auto content() const {
		static_assert(field_signatures[jField<F>("content")] != -1);
		return at<F>("content");
	}

	template<typename F = ::java::lang::Object>
	auto data() const {
		static_assert(field_signatures[jField<F>("data")] != -1);
		return at<F>("data");
	}

	template<typename F = ::java::util::BitSet>
	auto exclusions() const {
		static_assert(field_signatures[jField<F>("exclusions")] != -1);
		return at<F>("exclusions");
	}

	template<typename F = ::java::util::BitSet>
	auto inclusions() const {
		static_assert(field_signatures[jField<F>("inclusions")] != -1);
		return at<F>("inclusions");
	}

	template<typename F = ::jint>
	auto index() const {
		static_assert(field_signatures[jField<F>("index")] != -1);
		return at<F>("index");
	}

	template<typename F = ::java::lang::String>
	auto name() const {
		static_assert(field_signatures[jField<F>("name")] != -1);
		return at<F>("name");
	}

	template<typename F = ::jboolean>
	auto oEnd() const {
		static_assert(field_signatures[jField<F>("oEnd")] != -1);
		return at<F>("oEnd");
	}

	template<typename F = ::jboolean>
	auto oStart() const {
		static_assert(field_signatures[jField<F>("oStart")] != -1);
		return at<F>("oStart");
	}

	template<typename F = ::jint>
	auto type() const {
		static_assert(field_signatures[jField<F>("type")] != -1);
		return at<F>("type");
	}

	constexpr static Enume method_signatures{
		jMethod<::javax::swing::text::html::parser::AttributeList(::java::lang::String)>("getAttribute"), //
		jMethod<::javax::swing::text::html::parser::AttributeList(::java::lang::String)>("getAttributeByValue"), //
		jMethod<::javax::swing::text::html::parser::AttributeList()>("getAttributes"), //
		jMethod<::javax::swing::text::html::parser::ContentModel()>("getContent"), //
		jMethod<::jint()>("getIndex"), //
		jMethod<::java::lang::String()>("getName"), //
		jMethod<::jint()>("getType"), //
		jMethod<::jboolean()>("isEmpty"), //
		jMethod<::jint(::java::lang::String)>("name2type"), //
		jMethod<::jboolean()>("omitEnd"), //
		jMethod<::jboolean()>("omitStart"), //
		jMethod<::java::lang::String()>("toString"), //
	};

	template<typename R = ::javax::swing::text::html::parser::AttributeList, typename... Args>
	auto getAttribute(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAttribute")] != -1);
		return call<R>("getAttribute", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::text::html::parser::AttributeList, typename... Args>
	auto getAttributeByValue(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAttributeByValue")] != -1);
		return call<R>("getAttributeByValue", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::text::html::parser::AttributeList, typename... Args>
	auto getAttributes(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAttributes")] != -1);
		return call<R>("getAttributes", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::text::html::parser::ContentModel, typename... Args>
	auto getContent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getContent")] != -1);
		return call<R>("getContent", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getIndex(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getIndex")] != -1);
		return call<R>("getIndex", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getName")] != -1);
		return call<R>("getName", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getType(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getType")] != -1);
		return call<R>("getType", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isEmpty(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isEmpty")] != -1);
		return call<R>("isEmpty", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto name2type(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("name2type")] != -1);
		return scall<R>("name2type", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto omitEnd(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("omitEnd")] != -1);
		return call<R>("omitEnd", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto omitStart(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("omitStart")] != -1);
		return call<R>("omitStart", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

};

#endif
