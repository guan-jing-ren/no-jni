#ifndef javax_swing_plaf_metal_MetalComboBoxButton_HPP
#define javax_swing_plaf_metal_MetalComboBoxButton_HPP

#include "../../../../jfwd_decl.hpp"

class ::javax::swing::plaf::metal::MetalComboBoxButton : public jObject<::javax::swing::plaf::metal::MetalComboBoxButton, ::javax::swing::JButton> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::javax_swing_plaf_metal / "MetalComboBoxButton";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid(::javax::swing::JComboBox, ::javax::swing::Icon, ::javax::swing::CellRendererPane, ::javax::swing::JList)>(), //
		jConstructor<::jvoid(::javax::swing::JComboBox, ::javax::swing::Icon, ::jboolean, ::javax::swing::CellRendererPane, ::javax::swing::JList)>(), //
		jMethod<::javax::swing::JComboBox()>("getComboBox"), //
		jMethod<::javax::swing::Icon()>("getComboIcon"), //
		jMethod<::java::awt::Dimension()>("getMinimumSize"), //
		jMethod<::jboolean()>("isFocusTraversable"), //
		jMethod<::jboolean()>("isIconOnly"), //
		jMethod<::jvoid(::java::awt::Graphics)>("paintComponent"), //
		jMethod<::jvoid(::javax::swing::JComboBox)>("setComboBox"), //
		jMethod<::jvoid(::javax::swing::Icon)>("setComboIcon"), //
		jMethod<::jvoid(::jboolean)>("setEnabled"), //
		jMethod<::jvoid(::jboolean)>("setIconOnly"), //
	};

	template<typename R = ::javax::swing::JComboBox, typename... Args>
	auto getComboBox(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getComboBox")] != -1);
		return call<R>("getComboBox", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::Icon, typename... Args>
	auto getComboIcon(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getComboIcon")] != -1);
		return call<R>("getComboIcon", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::Dimension, typename... Args>
	auto getMinimumSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getMinimumSize")] != -1);
		return call<R>("getMinimumSize", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isFocusTraversable(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isFocusTraversable")] != -1);
		return call<R>("isFocusTraversable", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isIconOnly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isIconOnly")] != -1);
		return call<R>("isIconOnly", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto paintComponent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("paintComponent")] != -1);
		return call<R>("paintComponent", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setComboBox(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setComboBox")] != -1);
		return call<R>("setComboBox", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setComboIcon(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setComboIcon")] != -1);
		return call<R>("setComboIcon", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setEnabled")] != -1);
		return call<R>("setEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setIconOnly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setIconOnly")] != -1);
		return call<R>("setIconOnly", std::forward<Args>(args)...);
	}

};

#endif
