#ifndef sun_reflect_LangReflectAccess_HPP
#define sun_reflect_LangReflectAccess_HPP

#include "../../jfwd_decl.hpp"

class ::sun::reflect::LangReflectAccess : public jObject<::sun::reflect::LangReflectAccess, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_reflect / "LangReflectAccess";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::lang::reflect::Constructor(::java::lang::reflect::Constructor)>("copyConstructor"), //
		jMethod<::java::lang::reflect::Field(::java::lang::reflect::Field)>("copyField"), //
		jMethod<::java::lang::reflect::Method(::java::lang::reflect::Method)>("copyMethod"), //
		jMethod<::sun::reflect::ConstructorAccessor(::java::lang::reflect::Constructor)>("getConstructorAccessor"), //
		jMethod<::jbyte *(::java::lang::reflect::Constructor)>("getConstructorAnnotations"), //
		jMethod<::jbyte *(::java::lang::reflect::Constructor)>("getConstructorParameterAnnotations"), //
		jMethod<::java::lang::String(::java::lang::reflect::Constructor)>("getConstructorSignature"), //
		jMethod<::jint(::java::lang::reflect::Constructor)>("getConstructorSlot"), //
		jMethod<::jbyte *(::java::lang::reflect::Executable)>("getExecutableTypeAnnotationBytes"), //
		jMethod<::sun::reflect::MethodAccessor(::java::lang::reflect::Method)>("getMethodAccessor"), //
		jMethod<::java::lang::reflect::Constructor(::java::lang::Class, ::java::lang::Class *, ::java::lang::Class *, ::jint, ::jint, ::java::lang::String, ::jbyte *, ::jbyte *)>("newConstructor"), //
		jMethod<::java::lang::reflect::Field(::java::lang::Class, ::java::lang::String, ::java::lang::Class, ::jint, ::jint, ::java::lang::String, ::jbyte *)>("newField"), //
		jMethod<::java::lang::reflect::Method(::java::lang::Class, ::java::lang::String, ::java::lang::Class *, ::java::lang::Class, ::java::lang::Class *, ::jint, ::jint, ::java::lang::String, ::jbyte *, ::jbyte *, ::jbyte *)>("newMethod"), //
		jMethod<::jvoid(::java::lang::reflect::Constructor, ::sun::reflect::ConstructorAccessor)>("setConstructorAccessor"), //
		jMethod<::jvoid(::java::lang::reflect::Method, ::sun::reflect::MethodAccessor)>("setMethodAccessor"), //
	};

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto copyConstructor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyConstructor")] != -1);
		return call<R>("copyConstructor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Field, typename... Args>
	auto copyField(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyField")] != -1);
		return call<R>("copyField", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Method, typename... Args>
	auto copyMethod(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyMethod")] != -1);
		return call<R>("copyMethod", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::ConstructorAccessor, typename... Args>
	auto getConstructorAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorAccessor")] != -1);
		return call<R>("getConstructorAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	auto getConstructorAnnotations(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorAnnotations")] != -1);
		return call<R>("getConstructorAnnotations", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	auto getConstructorParameterAnnotations(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorParameterAnnotations")] != -1);
		return call<R>("getConstructorParameterAnnotations", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getConstructorSignature(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorSignature")] != -1);
		return call<R>("getConstructorSignature", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getConstructorSlot(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorSlot")] != -1);
		return call<R>("getConstructorSlot", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	auto getExecutableTypeAnnotationBytes(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getExecutableTypeAnnotationBytes")] != -1);
		return call<R>("getExecutableTypeAnnotationBytes", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::MethodAccessor, typename... Args>
	auto getMethodAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getMethodAccessor")] != -1);
		return call<R>("getMethodAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto newConstructor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newConstructor")] != -1);
		return call<R>("newConstructor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Field, typename... Args>
	auto newField(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newField")] != -1);
		return call<R>("newField", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Method, typename... Args>
	auto newMethod(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newMethod")] != -1);
		return call<R>("newMethod", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setConstructorAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setConstructorAccessor")] != -1);
		return call<R>("setConstructorAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setMethodAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setMethodAccessor")] != -1);
		return call<R>("setMethodAccessor", std::forward<Args>(args)...);
	}

};

#endif
