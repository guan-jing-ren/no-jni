#ifndef sun_reflect_ReflectionFactory_HPP
#define sun_reflect_ReflectionFactory_HPP

#include "../../jfwd_decl.hpp"

class ::sun::reflect::ReflectionFactory : public jObject<::sun::reflect::ReflectionFactory, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_reflect / "ReflectionFactory";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::lang::reflect::Constructor(::java::lang::reflect::Constructor)>("copyConstructor"), //
		jMethod<::java::lang::reflect::Field(::java::lang::reflect::Field)>("copyField"), //
		jMethod<::java::lang::reflect::Method(::java::lang::reflect::Method)>("copyMethod"), //
		jMethod<::sun::reflect::ConstructorAccessor(::java::lang::reflect::Constructor)>("getConstructorAccessor"), //
		jMethod<::jbyte *(::java::lang::reflect::Executable)>("getExecutableTypeAnnotationBytes"), //
		jMethod<::sun::reflect::MethodAccessor(::java::lang::reflect::Method)>("getMethodAccessor"), //
		jMethod<::sun::reflect::ReflectionFactory()>("getReflectionFactory"), //
		jMethod<::jboolean(::java::lang::Class)>("hasStaticInitializerForSerialization"), //
		jMethod<::java::lang::reflect::Constructor(::java::lang::Class, ::java::lang::Class *, ::java::lang::Class *, ::jint, ::jint, ::java::lang::String, ::jbyte *, ::jbyte *)>("newConstructor"), //
		jMethod<::sun::reflect::ConstructorAccessor(::java::lang::reflect::Constructor)>("newConstructorAccessor"), //
		jMethod<::java::lang::reflect::Constructor(::java::lang::Class)>("newConstructorForExternalization"), //
		jMethod<::java::lang::reflect::Constructor(::java::lang::Class)>("newConstructorForSerialization"), //
		jMethod<::java::lang::reflect::Constructor(::java::lang::Class, ::java::lang::reflect::Constructor)>("newConstructorForSerialization"), //
		jMethod<::java::lang::reflect::Field(::java::lang::Class, ::java::lang::String, ::java::lang::Class, ::jint, ::jint, ::java::lang::String, ::jbyte *)>("newField"), //
		jMethod<::sun::reflect::FieldAccessor(::java::lang::reflect::Field, ::jboolean)>("newFieldAccessor"), //
		jMethod<::java::lang::reflect::Method(::java::lang::Class, ::java::lang::String, ::java::lang::Class *, ::java::lang::Class, ::java::lang::Class *, ::jint, ::jint, ::java::lang::String, ::jbyte *, ::jbyte *, ::jbyte *)>("newMethod"), //
		jMethod<::sun::reflect::MethodAccessor(::java::lang::reflect::Method)>("newMethodAccessor"), //
		jMethod<::java::io::OptionalDataException(::jboolean)>("newOptionalDataExceptionForSerialization"), //
		jMethod<::java::lang::invoke::MethodHandle(::java::lang::Class)>("readObjectForSerialization"), //
		jMethod<::java::lang::invoke::MethodHandle(::java::lang::Class)>("readObjectNoDataForSerialization"), //
		jMethod<::java::lang::invoke::MethodHandle(::java::lang::Class)>("readResolveForSerialization"), //
		jMethod<::jvoid(::java::lang::reflect::Constructor, ::sun::reflect::ConstructorAccessor)>("setConstructorAccessor"), //
		jMethod<::jvoid(::sun::reflect::LangReflectAccess)>("setLangReflectAccess"), //
		jMethod<::jvoid(::java::lang::reflect::Method, ::sun::reflect::MethodAccessor)>("setMethodAccessor"), //
		jMethod<::java::lang::invoke::MethodHandle(::java::lang::Class)>("writeObjectForSerialization"), //
		jMethod<::java::lang::invoke::MethodHandle(::java::lang::Class)>("writeReplaceForSerialization"), //
	};

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto copyConstructor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyConstructor")] != -1);
		return call<R>("copyConstructor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Field, typename... Args>
	auto copyField(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyField")] != -1);
		return call<R>("copyField", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Method, typename... Args>
	auto copyMethod(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyMethod")] != -1);
		return call<R>("copyMethod", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::ConstructorAccessor, typename... Args>
	auto getConstructorAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getConstructorAccessor")] != -1);
		return call<R>("getConstructorAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte *, typename... Args>
	auto getExecutableTypeAnnotationBytes(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getExecutableTypeAnnotationBytes")] != -1);
		return call<R>("getExecutableTypeAnnotationBytes", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::MethodAccessor, typename... Args>
	auto getMethodAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getMethodAccessor")] != -1);
		return call<R>("getMethodAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::ReflectionFactory, typename... Args>
	static auto getReflectionFactory(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getReflectionFactory")] != -1);
		return scall<R>("getReflectionFactory", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasStaticInitializerForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasStaticInitializerForSerialization")] != -1);
		return call<R>("hasStaticInitializerForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto newConstructor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newConstructor")] != -1);
		return call<R>("newConstructor", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::ConstructorAccessor, typename... Args>
	auto newConstructorAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newConstructorAccessor")] != -1);
		return call<R>("newConstructorAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto newConstructorForExternalization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newConstructorForExternalization")] != -1);
		return call<R>("newConstructorForExternalization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Constructor, typename... Args>
	auto newConstructorForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newConstructorForSerialization")] != -1);
		return call<R>("newConstructorForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Field, typename... Args>
	auto newField(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newField")] != -1);
		return call<R>("newField", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::FieldAccessor, typename... Args>
	auto newFieldAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newFieldAccessor")] != -1);
		return call<R>("newFieldAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::reflect::Method, typename... Args>
	auto newMethod(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newMethod")] != -1);
		return call<R>("newMethod", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::reflect::MethodAccessor, typename... Args>
	auto newMethodAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newMethodAccessor")] != -1);
		return call<R>("newMethodAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::io::OptionalDataException, typename... Args>
	auto newOptionalDataExceptionForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newOptionalDataExceptionForSerialization")] != -1);
		return call<R>("newOptionalDataExceptionForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::invoke::MethodHandle, typename... Args>
	auto readObjectForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("readObjectForSerialization")] != -1);
		return call<R>("readObjectForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::invoke::MethodHandle, typename... Args>
	auto readObjectNoDataForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("readObjectNoDataForSerialization")] != -1);
		return call<R>("readObjectNoDataForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::invoke::MethodHandle, typename... Args>
	auto readResolveForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("readResolveForSerialization")] != -1);
		return call<R>("readResolveForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setConstructorAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setConstructorAccessor")] != -1);
		return call<R>("setConstructorAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setLangReflectAccess(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setLangReflectAccess")] != -1);
		return call<R>("setLangReflectAccess", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setMethodAccessor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setMethodAccessor")] != -1);
		return call<R>("setMethodAccessor", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::invoke::MethodHandle, typename... Args>
	auto writeObjectForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("writeObjectForSerialization")] != -1);
		return call<R>("writeObjectForSerialization", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::invoke::MethodHandle, typename... Args>
	auto writeReplaceForSerialization(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("writeReplaceForSerialization")] != -1);
		return call<R>("writeReplaceForSerialization", std::forward<Args>(args)...);
	}

};

#endif
