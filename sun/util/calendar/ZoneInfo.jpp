#ifndef sun_util_calendar_ZoneInfo_HPP
#define sun_util_calendar_ZoneInfo_HPP

#include "../../../jfwd_decl.hpp"

class ::sun::util::calendar::ZoneInfo : public jObject<::sun::util::calendar::ZoneInfo, ::java::util::TimeZone> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_util_calendar / "ZoneInfo";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jConstructor<::jvoid(::java::lang::String, ::jint)>(), //
		jMethod<::java::lang::Object()>("clone"), //
		jMethod<::jboolean(::java::lang::Object)>("equals"), //
		jMethod<::java::util::Map()>("getAliasTable"), //
		jMethod<::java::lang::String *()>("getAvailableIDs"), //
		jMethod<::java::lang::String *(::jint)>("getAvailableIDs"), //
		jMethod<::jint()>("getDSTSavings"), //
		jMethod<::java::util::SimpleTimeZone()>("getLastRuleInstance"), //
		jMethod<::jint(::jint, ::jint, ::jint, ::jint, ::jint, ::jint)>("getOffset"), //
		jMethod<::jint(::jlong)>("getOffset"), //
		jMethod<::jint(::jlong, ::jint *)>("getOffsets"), //
		jMethod<::jint(::jlong, ::jint *)>("getOffsetsByStandard"), //
		jMethod<::jint(::jlong, ::jint *)>("getOffsetsByWall"), //
		jMethod<::jint()>("getRawOffset"), //
		jMethod<::java::util::TimeZone(::java::lang::String)>("getTimeZone"), //
		jMethod<::jboolean(::java::util::TimeZone)>("hasSameRules"), //
		jMethod<::jint()>("hashCode"), //
		jMethod<::jboolean(::java::util::Date)>("inDaylightTime"), //
		jMethod<::jboolean()>("isDirty"), //
		jMethod<::jboolean()>("observesDaylightTime"), //
		jMethod<::jvoid(::jint)>("setRawOffset"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::jboolean()>("useDaylightTime"), //
	};

	template<typename R = ::java::lang::Object, typename... Args>
	auto clone(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("clone")] != -1);
		return call<R>("clone", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto equals(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("equals")] != -1);
		return call<R>("equals", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Map, typename... Args>
	static auto getAliasTable(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAliasTable")] != -1);
		return scall<R>("getAliasTable", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String *, typename... Args>
	static auto getAvailableIDs(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAvailableIDs")] != -1);
		return scall<R>("getAvailableIDs", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getDSTSavings(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDSTSavings")] != -1);
		return call<R>("getDSTSavings", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::SimpleTimeZone, typename... Args>
	auto getLastRuleInstance(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getLastRuleInstance")] != -1);
		return call<R>("getLastRuleInstance", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getOffset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getOffset")] != -1);
		return call<R>("getOffset", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getOffsets(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getOffsets")] != -1);
		return call<R>("getOffsets", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getOffsetsByStandard(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getOffsetsByStandard")] != -1);
		return call<R>("getOffsetsByStandard", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getOffsetsByWall(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getOffsetsByWall")] != -1);
		return call<R>("getOffsetsByWall", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getRawOffset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRawOffset")] != -1);
		return call<R>("getRawOffset", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::TimeZone, typename... Args>
	static auto getTimeZone(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTimeZone")] != -1);
		return scall<R>("getTimeZone", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasSameRules(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasSameRules")] != -1);
		return call<R>("hasSameRules", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto hashCode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hashCode")] != -1);
		return call<R>("hashCode", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto inDaylightTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("inDaylightTime")] != -1);
		return call<R>("inDaylightTime", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isDirty(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isDirty")] != -1);
		return call<R>("isDirty", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto observesDaylightTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("observesDaylightTime")] != -1);
		return call<R>("observesDaylightTime", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setRawOffset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setRawOffset")] != -1);
		return call<R>("setRawOffset", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto useDaylightTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useDaylightTime")] != -1);
		return call<R>("useDaylightTime", std::forward<Args>(args)...);
	}

};

#endif
