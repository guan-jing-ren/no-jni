#ifndef sun_text_normalizer_NormalizerImpl_HPP
#define sun_text_normalizer_NormalizerImpl_HPP

#include "../../../jfwd_decl.hpp"

class ::sun::text::normalizer::NormalizerImpl : public jObject<::sun::text::normalizer::NormalizerImpl, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_text_normalizer / "NormalizerImpl";

	constexpr static Enume field_signatures{
		jField<::jint>("BEFORE_PRI_29"), //
		jField<::jint>("CC_MASK"), //
		jField<::jint>("COMBINES_ANY"), //
		jField<::jint>("HANGUL_BASE"), //
		jField<::jint>("HANGUL_COUNT"), //
		jField<::jint>("INDEX_MIN_NFC_NO_MAYBE"), //
		jField<::jint>("INDEX_MIN_NFD_NO_MAYBE"), //
		jField<::jint>("INDEX_MIN_NFKC_NO_MAYBE"), //
		jField<::jint>("INDEX_MIN_NFKD_NO_MAYBE"), //
		jField<::jint>("JAMO_L_BASE"), //
		jField<::jint>("JAMO_L_COUNT"), //
		jField<::jint>("JAMO_T_BASE"), //
		jField<::jint>("JAMO_T_COUNT"), //
		jField<::jint>("JAMO_V_BASE"), //
		jField<::jint>("JAMO_V_COUNT"), //
		jField<::jint>("MIN_WITH_LEAD_CC"), //
		jField<::jint>("OPTIONS_COMPAT"), //
		jField<::jint>("OPTIONS_COMPOSE_CONTIGUOUS"), //
		jField<::jint>("OPTIONS_SETS_MASK"), //
		jField<::jint>("QC_ANY_MAYBE"), //
		jField<::jint>("QC_ANY_NO"), //
		jField<::jint>("QC_MASK"), //
		jField<::jint>("QC_MAYBE"), //
		jField<::jint>("QC_NFC"), //
		jField<::jint>("QC_NFD"), //
		jField<::jint>("QC_NFKC"), //
		jField<::jint>("QC_NFKD"), //
		jField<::jint>("WITHOUT_CORRIGENDUM4_CORRECTIONS"), //
	};

	template<typename F = ::jint>
	static auto BEFORE_PRI_29() {
		static_assert(field_signatures[jField<F>("BEFORE_PRI_29")] != -1);
		return sat<F>("BEFORE_PRI_29");
	}

	template<typename F = ::jint>
	static auto CC_MASK() {
		static_assert(field_signatures[jField<F>("CC_MASK")] != -1);
		return sat<F>("CC_MASK");
	}

	template<typename F = ::jint>
	static auto COMBINES_ANY() {
		static_assert(field_signatures[jField<F>("COMBINES_ANY")] != -1);
		return sat<F>("COMBINES_ANY");
	}

	template<typename F = ::jint>
	static auto HANGUL_BASE() {
		static_assert(field_signatures[jField<F>("HANGUL_BASE")] != -1);
		return sat<F>("HANGUL_BASE");
	}

	template<typename F = ::jint>
	static auto HANGUL_COUNT() {
		static_assert(field_signatures[jField<F>("HANGUL_COUNT")] != -1);
		return sat<F>("HANGUL_COUNT");
	}

	template<typename F = ::jint>
	static auto INDEX_MIN_NFC_NO_MAYBE() {
		static_assert(field_signatures[jField<F>("INDEX_MIN_NFC_NO_MAYBE")] != -1);
		return sat<F>("INDEX_MIN_NFC_NO_MAYBE");
	}

	template<typename F = ::jint>
	static auto INDEX_MIN_NFD_NO_MAYBE() {
		static_assert(field_signatures[jField<F>("INDEX_MIN_NFD_NO_MAYBE")] != -1);
		return sat<F>("INDEX_MIN_NFD_NO_MAYBE");
	}

	template<typename F = ::jint>
	static auto INDEX_MIN_NFKC_NO_MAYBE() {
		static_assert(field_signatures[jField<F>("INDEX_MIN_NFKC_NO_MAYBE")] != -1);
		return sat<F>("INDEX_MIN_NFKC_NO_MAYBE");
	}

	template<typename F = ::jint>
	static auto INDEX_MIN_NFKD_NO_MAYBE() {
		static_assert(field_signatures[jField<F>("INDEX_MIN_NFKD_NO_MAYBE")] != -1);
		return sat<F>("INDEX_MIN_NFKD_NO_MAYBE");
	}

	template<typename F = ::jint>
	static auto JAMO_L_BASE() {
		static_assert(field_signatures[jField<F>("JAMO_L_BASE")] != -1);
		return sat<F>("JAMO_L_BASE");
	}

	template<typename F = ::jint>
	static auto JAMO_L_COUNT() {
		static_assert(field_signatures[jField<F>("JAMO_L_COUNT")] != -1);
		return sat<F>("JAMO_L_COUNT");
	}

	template<typename F = ::jint>
	static auto JAMO_T_BASE() {
		static_assert(field_signatures[jField<F>("JAMO_T_BASE")] != -1);
		return sat<F>("JAMO_T_BASE");
	}

	template<typename F = ::jint>
	static auto JAMO_T_COUNT() {
		static_assert(field_signatures[jField<F>("JAMO_T_COUNT")] != -1);
		return sat<F>("JAMO_T_COUNT");
	}

	template<typename F = ::jint>
	static auto JAMO_V_BASE() {
		static_assert(field_signatures[jField<F>("JAMO_V_BASE")] != -1);
		return sat<F>("JAMO_V_BASE");
	}

	template<typename F = ::jint>
	static auto JAMO_V_COUNT() {
		static_assert(field_signatures[jField<F>("JAMO_V_COUNT")] != -1);
		return sat<F>("JAMO_V_COUNT");
	}

	template<typename F = ::jint>
	static auto MIN_WITH_LEAD_CC() {
		static_assert(field_signatures[jField<F>("MIN_WITH_LEAD_CC")] != -1);
		return sat<F>("MIN_WITH_LEAD_CC");
	}

	template<typename F = ::jint>
	static auto OPTIONS_COMPAT() {
		static_assert(field_signatures[jField<F>("OPTIONS_COMPAT")] != -1);
		return sat<F>("OPTIONS_COMPAT");
	}

	template<typename F = ::jint>
	static auto OPTIONS_COMPOSE_CONTIGUOUS() {
		static_assert(field_signatures[jField<F>("OPTIONS_COMPOSE_CONTIGUOUS")] != -1);
		return sat<F>("OPTIONS_COMPOSE_CONTIGUOUS");
	}

	template<typename F = ::jint>
	static auto OPTIONS_SETS_MASK() {
		static_assert(field_signatures[jField<F>("OPTIONS_SETS_MASK")] != -1);
		return sat<F>("OPTIONS_SETS_MASK");
	}

	template<typename F = ::jint>
	static auto QC_ANY_MAYBE() {
		static_assert(field_signatures[jField<F>("QC_ANY_MAYBE")] != -1);
		return sat<F>("QC_ANY_MAYBE");
	}

	template<typename F = ::jint>
	static auto QC_ANY_NO() {
		static_assert(field_signatures[jField<F>("QC_ANY_NO")] != -1);
		return sat<F>("QC_ANY_NO");
	}

	template<typename F = ::jint>
	static auto QC_MASK() {
		static_assert(field_signatures[jField<F>("QC_MASK")] != -1);
		return sat<F>("QC_MASK");
	}

	template<typename F = ::jint>
	static auto QC_MAYBE() {
		static_assert(field_signatures[jField<F>("QC_MAYBE")] != -1);
		return sat<F>("QC_MAYBE");
	}

	template<typename F = ::jint>
	static auto QC_NFC() {
		static_assert(field_signatures[jField<F>("QC_NFC")] != -1);
		return sat<F>("QC_NFC");
	}

	template<typename F = ::jint>
	static auto QC_NFD() {
		static_assert(field_signatures[jField<F>("QC_NFD")] != -1);
		return sat<F>("QC_NFD");
	}

	template<typename F = ::jint>
	static auto QC_NFKC() {
		static_assert(field_signatures[jField<F>("QC_NFKC")] != -1);
		return sat<F>("QC_NFKC");
	}

	template<typename F = ::jint>
	static auto QC_NFKD() {
		static_assert(field_signatures[jField<F>("QC_NFKD")] != -1);
		return sat<F>("QC_NFKD");
	}

	template<typename F = ::jint>
	static auto WITHOUT_CORRIGENDUM4_CORRECTIONS() {
		static_assert(field_signatures[jField<F>("WITHOUT_CORRIGENDUM4_CORRECTIONS")] != -1);
		return sat<F>("WITHOUT_CORRIGENDUM4_CORRECTIONS");
	}

	constexpr static Enume method_signatures{
		jMethod<::sun::text::normalizer::UnicodeSet(::sun::text::normalizer::UnicodeSet)>("addPropertyStarts"), //
		jMethod<::java::lang::String(::java::lang::String)>("canonicalDecomposeWithSingleQuotation"), //
		jMethod<::jint(::jchar *, ::jint, ::jint, ::jchar *, ::jint, ::jint, ::jint, ::sun::text::normalizer::UnicodeSet)>("compose"), //
		jMethod<::java::lang::String(::java::lang::String)>("convert"), //
		jMethod<::jint(::jchar *, ::jint, ::jint, ::jchar *, ::jint, ::jint, ::jboolean, ::jint *, ::sun::text::normalizer::UnicodeSet)>("decompose"), //
		jMethod<::jint(::jint)>("getCombiningClass"), //
		jMethod<::jint(::jint *, ::java::lang::String *)>("getDecompose"), //
		jMethod<::jchar(::jchar)>("getFCD16"), //
		jMethod<::jint(::jint)>("getFCD16"), //
		jMethod<::jchar(::jchar, ::jchar)>("getFCD16FromSurrogatePair"), //
		jMethod<::jint(::jint)>("getFromIndexesArr"), //
		jMethod<::sun::text::normalizer::UnicodeSet(::jint)>("getNX"), //
		jMethod<::jlong(::jchar)>("getNorm32"), //
		jMethod<::jlong(::jlong, ::jchar)>("getNorm32FromSurrogatePair"), //
		jMethod<::sun::text::normalizer::VersionInfo()>("getUnicodeVersion"), //
		jMethod<::jboolean(::jint)>("isCanonSafeStart"), //
		jMethod<::jboolean(::jint)>("isFullCompositionExclusion"), //
		jMethod<::jboolean(::jlong, ::jint, ::jint)>("isNFDSafe"), //
		jMethod<::jboolean(::jint, ::sun::text::normalizer::NormalizerBase$Mode, ::jlong)>("isNFSkippable"), //
		jMethod<::jboolean(::jlong, ::jint, ::jint)>("isTrueStarter"), //
		jMethod<::jint(::jint, ::jint)>("quickCheck"), //
		jMethod<::sun::text::normalizer::NormalizerBase$QuickCheckResult(::jchar *, ::jint, ::jint, ::jint, ::jint, ::jint, ::jboolean, ::sun::text::normalizer::UnicodeSet)>("quickCheck"), //
	};

	template<typename R = ::sun::text::normalizer::UnicodeSet, typename... Args>
	static auto addPropertyStarts(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("addPropertyStarts")] != -1);
		return scall<R>("addPropertyStarts", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto canonicalDecomposeWithSingleQuotation(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("canonicalDecomposeWithSingleQuotation")] != -1);
		return scall<R>("canonicalDecomposeWithSingleQuotation", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto compose(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("compose")] != -1);
		return scall<R>("compose", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto convert(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("convert")] != -1);
		return scall<R>("convert", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto decompose(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("decompose")] != -1);
		return scall<R>("decompose", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto getCombiningClass(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getCombiningClass")] != -1);
		return scall<R>("getCombiningClass", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto getDecompose(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDecompose")] != -1);
		return scall<R>("getDecompose", std::forward<Args>(args)...);
	}

	template<typename R = ::jchar, typename... Args>
	static auto getFCD16(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFCD16")] != -1);
		return scall<R>("getFCD16", std::forward<Args>(args)...);
	}

	template<typename R = ::jchar, typename... Args>
	static auto getFCD16FromSurrogatePair(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFCD16FromSurrogatePair")] != -1);
		return scall<R>("getFCD16FromSurrogatePair", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto getFromIndexesArr(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFromIndexesArr")] != -1);
		return scall<R>("getFromIndexesArr", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::text::normalizer::UnicodeSet, typename... Args>
	static auto getNX(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getNX")] != -1);
		return scall<R>("getNX", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	static auto getNorm32(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getNorm32")] != -1);
		return scall<R>("getNorm32", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	static auto getNorm32FromSurrogatePair(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getNorm32FromSurrogatePair")] != -1);
		return scall<R>("getNorm32FromSurrogatePair", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::text::normalizer::VersionInfo, typename... Args>
	static auto getUnicodeVersion(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getUnicodeVersion")] != -1);
		return scall<R>("getUnicodeVersion", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isCanonSafeStart(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isCanonSafeStart")] != -1);
		return scall<R>("isCanonSafeStart", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isFullCompositionExclusion(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isFullCompositionExclusion")] != -1);
		return scall<R>("isFullCompositionExclusion", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isNFDSafe(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isNFDSafe")] != -1);
		return scall<R>("isNFDSafe", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isNFSkippable(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isNFSkippable")] != -1);
		return scall<R>("isNFSkippable", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isTrueStarter(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isTrueStarter")] != -1);
		return scall<R>("isTrueStarter", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto quickCheck(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("quickCheck")] != -1);
		return scall<R>("quickCheck", std::forward<Args>(args)...);
	}

};

#endif
