#ifndef sun_nio_fs_UnixFileSystemProvider_HPP
#define sun_nio_fs_UnixFileSystemProvider_HPP

#include "../../../jfwd_decl.hpp"

class ::sun::nio::fs::UnixFileSystemProvider : public jObject<::sun::nio::fs::UnixFileSystemProvider, ::sun::nio::fs::AbstractFileSystemProvider> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_nio_fs / "UnixFileSystemProvider";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::AccessMode *)>("checkAccess"), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::Path, ::java::nio::file::CopyOption *)>("copy"), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::attribute::FileAttribute *)>("createDirectory"), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::Path)>("createLink"), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::Path, ::java::nio::file::attribute::FileAttribute *)>("createSymbolicLink"), //
		jMethod<::java::nio::file::attribute::FileAttributeView(::java::nio::file::Path, ::java::lang::Class, ::java::nio::file::LinkOption *)>("getFileAttributeView"), //
		jMethod<::java::nio::file::FileStore(::java::nio::file::Path)>("getFileStore"), //
		jMethod<::java::nio::file::FileSystem(::java::net::URI)>("getFileSystem"), //
		jMethod<::java::nio::file::Path(::java::net::URI)>("getPath"), //
		jMethod<::java::lang::String()>("getScheme"), //
		jMethod<::jboolean(::java::nio::file::Path)>("isHidden"), //
		jMethod<::jboolean(::java::nio::file::Path, ::java::nio::file::Path)>("isSameFile"), //
		jMethod<::jvoid(::java::nio::file::Path, ::java::nio::file::Path, ::java::nio::file::CopyOption *)>("move"), //
		jMethod<::java::nio::channels::AsynchronousFileChannel(::java::nio::file::Path, ::java::util::Set, ::java::util::concurrent::ExecutorService, ::java::nio::file::attribute::FileAttribute *)>("newAsynchronousFileChannel"), //
		jMethod<::java::nio::channels::SeekableByteChannel(::java::nio::file::Path, ::java::util::Set, ::java::nio::file::attribute::FileAttribute *)>("newByteChannel"), //
		jMethod<::java::nio::file::DirectoryStream(::java::nio::file::Path, ::java::nio::file::DirectoryStream$Filter)>("newDirectoryStream"), //
		jMethod<::java::nio::channels::FileChannel(::java::nio::file::Path, ::java::util::Set, ::java::nio::file::attribute::FileAttribute *)>("newFileChannel"), //
		jMethod<::java::nio::file::FileSystem(::java::net::URI, ::java::util::Map)>("newFileSystem"), //
		jMethod<::java::nio::file::attribute::BasicFileAttributes(::java::nio::file::Path, ::java::lang::Class, ::java::nio::file::LinkOption *)>("readAttributes"), //
		jMethod<::java::nio::file::Path(::java::nio::file::Path)>("readSymbolicLink"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto checkAccess(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("checkAccess")] != -1);
		return call<R>("checkAccess", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto copy(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copy")] != -1);
		return call<R>("copy", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto createDirectory(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createDirectory")] != -1);
		return call<R>("createDirectory", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto createLink(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createLink")] != -1);
		return call<R>("createLink", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto createSymbolicLink(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createSymbolicLink")] != -1);
		return call<R>("createSymbolicLink", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::attribute::FileAttributeView, typename... Args>
	auto getFileAttributeView(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFileAttributeView")] != -1);
		return call<R>("getFileAttributeView", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::FileStore, typename... Args>
	auto getFileStore(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFileStore")] != -1);
		return call<R>("getFileStore", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::FileSystem, typename... Args>
	auto getFileSystem(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getFileSystem")] != -1);
		return call<R>("getFileSystem", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::Path, typename... Args>
	auto getPath(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getPath")] != -1);
		return call<R>("getPath", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto getScheme(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getScheme")] != -1);
		return call<R>("getScheme", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isHidden(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isHidden")] != -1);
		return call<R>("isHidden", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSameFile(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSameFile")] != -1);
		return call<R>("isSameFile", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto move(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("move")] != -1);
		return call<R>("move", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::channels::AsynchronousFileChannel, typename... Args>
	auto newAsynchronousFileChannel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newAsynchronousFileChannel")] != -1);
		return call<R>("newAsynchronousFileChannel", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::channels::SeekableByteChannel, typename... Args>
	auto newByteChannel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newByteChannel")] != -1);
		return call<R>("newByteChannel", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::DirectoryStream, typename... Args>
	auto newDirectoryStream(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newDirectoryStream")] != -1);
		return call<R>("newDirectoryStream", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::channels::FileChannel, typename... Args>
	auto newFileChannel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newFileChannel")] != -1);
		return call<R>("newFileChannel", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::FileSystem, typename... Args>
	auto newFileSystem(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newFileSystem")] != -1);
		return call<R>("newFileSystem", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::attribute::BasicFileAttributes, typename... Args>
	auto readAttributes(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("readAttributes")] != -1);
		return call<R>("readAttributes", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::file::Path, typename... Args>
	auto readSymbolicLink(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("readSymbolicLink")] != -1);
		return call<R>("readSymbolicLink", std::forward<Args>(args)...);
	}

};

#endif
