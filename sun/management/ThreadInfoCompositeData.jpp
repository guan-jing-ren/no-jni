#ifndef sun_management_ThreadInfoCompositeData_HPP
#define sun_management_ThreadInfoCompositeData_HPP

#include "../../jfwd_decl.hpp"

class ::sun::management::ThreadInfoCompositeData : public jObject<::sun::management::ThreadInfoCompositeData, ::sun::management::LazyCompositeData> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_management / "ThreadInfoCompositeData";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jlong()>("blockedCount"), //
		jMethod<::jlong()>("blockedTime"), //
		jMethod<::sun::management::ThreadInfoCompositeData(::javax::management::openmbean::CompositeData)>("getInstance"), //
		jMethod<::java::lang::management::ThreadInfo()>("getThreadInfo"), //
		jMethod<::jboolean()>("inNative"), //
		jMethod<::jboolean()>("isCurrentVersion"), //
		jMethod<::jboolean(::javax::management::openmbean::CompositeData)>("isCurrentVersion"), //
		jMethod<::java::lang::management::LockInfo()>("lockInfo"), //
		jMethod<::java::lang::String()>("lockName"), //
		jMethod<::jlong()>("lockOwnerId"), //
		jMethod<::java::lang::String()>("lockOwnerName"), //
		jMethod<::java::lang::management::MonitorInfo *()>("lockedMonitors"), //
		jMethod<::java::lang::management::LockInfo *()>("lockedSynchronizers"), //
		jMethod<::java::lang::StackTraceElement *()>("stackTrace"), //
		jMethod<::jboolean()>("suspended"), //
		jMethod<::jlong()>("threadId"), //
		jMethod<::java::lang::String()>("threadName"), //
		jMethod<::java::lang::Thread$State()>("threadState"), //
		jMethod<::javax::management::openmbean::CompositeData(::java::lang::management::ThreadInfo)>("toCompositeData"), //
		jMethod<::jvoid(::javax::management::openmbean::CompositeData)>("validateCompositeData"), //
		jMethod<::jlong()>("waitedCount"), //
		jMethod<::jlong()>("waitedTime"), //
	};

	template<typename R = ::jlong, typename... Args>
	auto blockedCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("blockedCount")] != -1);
		return call<R>("blockedCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto blockedTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("blockedTime")] != -1);
		return call<R>("blockedTime", std::forward<Args>(args)...);
	}

	template<typename R = ::sun::management::ThreadInfoCompositeData, typename... Args>
	static auto getInstance(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getInstance")] != -1);
		return scall<R>("getInstance", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::management::ThreadInfo, typename... Args>
	auto getThreadInfo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getThreadInfo")] != -1);
		return call<R>("getThreadInfo", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto inNative(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("inNative")] != -1);
		return call<R>("inNative", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isCurrentVersion(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isCurrentVersion")] != -1);
		return call<R>("isCurrentVersion", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::management::LockInfo, typename... Args>
	auto lockInfo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockInfo")] != -1);
		return call<R>("lockInfo", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto lockName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockName")] != -1);
		return call<R>("lockName", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto lockOwnerId(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockOwnerId")] != -1);
		return call<R>("lockOwnerId", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto lockOwnerName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockOwnerName")] != -1);
		return call<R>("lockOwnerName", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::management::MonitorInfo *, typename... Args>
	auto lockedMonitors(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockedMonitors")] != -1);
		return call<R>("lockedMonitors", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::management::LockInfo *, typename... Args>
	auto lockedSynchronizers(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lockedSynchronizers")] != -1);
		return call<R>("lockedSynchronizers", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::StackTraceElement *, typename... Args>
	auto stackTrace(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("stackTrace")] != -1);
		return call<R>("stackTrace", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto suspended(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("suspended")] != -1);
		return call<R>("suspended", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto threadId(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("threadId")] != -1);
		return call<R>("threadId", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto threadName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("threadName")] != -1);
		return call<R>("threadName", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Thread$State, typename... Args>
	auto threadState(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("threadState")] != -1);
		return call<R>("threadState", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::management::openmbean::CompositeData, typename... Args>
	static auto toCompositeData(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toCompositeData")] != -1);
		return scall<R>("toCompositeData", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	static auto validateCompositeData(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("validateCompositeData")] != -1);
		return scall<R>("validateCompositeData", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto waitedCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("waitedCount")] != -1);
		return call<R>("waitedCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto waitedTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("waitedTime")] != -1);
		return call<R>("waitedTime", std::forward<Args>(args)...);
	}

};

#endif
