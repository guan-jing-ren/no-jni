#ifndef sun_swing_LightweightContent_HPP
#define sun_swing_LightweightContent_HPP

#include "../../jfwd_decl.hpp"

class ::sun::swing::LightweightContent : public jObject<::sun::swing::LightweightContent, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_swing / "LightweightContent";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jvoid(::java::awt::dnd::DropTarget)>("addDropTarget"), //
		jMethod<::java::awt::dnd::DragGestureRecognizer(::java::lang::Class, ::java::awt::dnd::DragSource, ::java::awt::Component, ::jint, ::java::awt::dnd::DragGestureListener)>("createDragGestureRecognizer"), //
		jMethod<::java::awt::dnd::peer::DragSourceContextPeer(::java::awt::dnd::DragGestureEvent)>("createDragSourceContextPeer"), //
		jMethod<::jvoid()>("focusGrabbed"), //
		jMethod<::jvoid()>("focusUngrabbed"), //
		jMethod<::javax::swing::JComponent()>("getComponent"), //
		jMethod<::jvoid(::jint *, ::jint, ::jint, ::jint, ::jint, ::jint)>("imageBufferReset"), //
		jMethod<::jvoid(::jint *, ::jint, ::jint, ::jint, ::jint, ::jint, ::jint)>("imageBufferReset"), //
		jMethod<::jvoid(::jint, ::jint, ::jint, ::jint)>("imageReshaped"), //
		jMethod<::jvoid(::jint, ::jint, ::jint, ::jint)>("imageUpdated"), //
		jMethod<::jvoid(::jint, ::jint)>("maximumSizeChanged"), //
		jMethod<::jvoid(::jint, ::jint)>("minimumSizeChanged"), //
		jMethod<::jvoid()>("paintLock"), //
		jMethod<::jvoid()>("paintUnlock"), //
		jMethod<::jvoid(::jint, ::jint)>("preferredSizeChanged"), //
		jMethod<::jvoid(::java::awt::dnd::DropTarget)>("removeDropTarget"), //
		jMethod<::jvoid(::java::awt::Cursor)>("setCursor"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto addDropTarget(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("addDropTarget")] != -1);
		return call<R>("addDropTarget", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::dnd::DragGestureRecognizer, typename... Args>
	auto createDragGestureRecognizer(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createDragGestureRecognizer")] != -1);
		return call<R>("createDragGestureRecognizer", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::dnd::peer::DragSourceContextPeer, typename... Args>
	auto createDragSourceContextPeer(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("createDragSourceContextPeer")] != -1);
		return call<R>("createDragSourceContextPeer", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto focusGrabbed(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("focusGrabbed")] != -1);
		return call<R>("focusGrabbed", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto focusUngrabbed(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("focusUngrabbed")] != -1);
		return call<R>("focusUngrabbed", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::swing::JComponent, typename... Args>
	auto getComponent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getComponent")] != -1);
		return call<R>("getComponent", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto imageBufferReset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("imageBufferReset")] != -1);
		return call<R>("imageBufferReset", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto imageReshaped(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("imageReshaped")] != -1);
		return call<R>("imageReshaped", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto imageUpdated(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("imageUpdated")] != -1);
		return call<R>("imageUpdated", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto maximumSizeChanged(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("maximumSizeChanged")] != -1);
		return call<R>("maximumSizeChanged", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto minimumSizeChanged(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("minimumSizeChanged")] != -1);
		return call<R>("minimumSizeChanged", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto paintLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("paintLock")] != -1);
		return call<R>("paintLock", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto paintUnlock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("paintUnlock")] != -1);
		return call<R>("paintUnlock", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto preferredSizeChanged(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("preferredSizeChanged")] != -1);
		return call<R>("preferredSizeChanged", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto removeDropTarget(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("removeDropTarget")] != -1);
		return call<R>("removeDropTarget", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setCursor(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setCursor")] != -1);
		return call<R>("setCursor", std::forward<Args>(args)...);
	}

};

#endif
