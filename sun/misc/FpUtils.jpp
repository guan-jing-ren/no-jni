#ifndef sun_misc_FpUtils_HPP
#define sun_misc_FpUtils_HPP

#include "../../jfwd_decl.hpp"

class ::sun::misc::FpUtils : public jObject<::sun::misc::FpUtils, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::sun_misc / "FpUtils";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jdouble(::jdouble, ::jdouble)>("copySign"), //
		jMethod<::jfloat(::jfloat, ::jfloat)>("copySign"), //
		jMethod<::jint(::jdouble)>("getExponent"), //
		jMethod<::jint(::jfloat)>("getExponent"), //
		jMethod<::jint(::jdouble)>("ilogb"), //
		jMethod<::jint(::jfloat)>("ilogb"), //
		jMethod<::jboolean(::jdouble)>("isFinite"), //
		jMethod<::jboolean(::jfloat)>("isFinite"), //
		jMethod<::jboolean(::jdouble)>("isInfinite"), //
		jMethod<::jboolean(::jfloat)>("isInfinite"), //
		jMethod<::jboolean(::jdouble)>("isNaN"), //
		jMethod<::jboolean(::jfloat)>("isNaN"), //
		jMethod<::jboolean(::jdouble, ::jdouble)>("isUnordered"), //
		jMethod<::jboolean(::jfloat, ::jfloat)>("isUnordered"), //
		jMethod<::jdouble(::jdouble, ::jdouble)>("nextAfter"), //
		jMethod<::jfloat(::jfloat, ::jdouble)>("nextAfter"), //
		jMethod<::jdouble(::jdouble)>("nextDown"), //
		jMethod<::jdouble(::jfloat)>("nextDown"), //
		jMethod<::jdouble(::jdouble)>("nextUp"), //
		jMethod<::jfloat(::jfloat)>("nextUp"), //
		jMethod<::jdouble(::jdouble, ::jdouble)>("rawCopySign"), //
		jMethod<::jfloat(::jfloat, ::jfloat)>("rawCopySign"), //
		jMethod<::jdouble(::jdouble, ::jint)>("scalb"), //
		jMethod<::jfloat(::jfloat, ::jint)>("scalb"), //
		jMethod<::jdouble(::jdouble)>("signum"), //
		jMethod<::jfloat(::jfloat)>("signum"), //
		jMethod<::jdouble(::jdouble)>("ulp"), //
		jMethod<::jfloat(::jfloat)>("ulp"), //
	};

	template<typename R = ::jdouble, typename... Args>
	static auto copySign(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copySign")] != -1);
		return scall<R>("copySign", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto getExponent(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getExponent")] != -1);
		return scall<R>("getExponent", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	static auto ilogb(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("ilogb")] != -1);
		return scall<R>("ilogb", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isFinite(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isFinite")] != -1);
		return scall<R>("isFinite", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isInfinite(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isInfinite")] != -1);
		return scall<R>("isInfinite", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isNaN(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isNaN")] != -1);
		return scall<R>("isNaN", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isUnordered(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isUnordered")] != -1);
		return scall<R>("isUnordered", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto nextAfter(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextAfter")] != -1);
		return scall<R>("nextAfter", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto nextDown(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextDown")] != -1);
		return scall<R>("nextDown", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto nextUp(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextUp")] != -1);
		return scall<R>("nextUp", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto rawCopySign(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("rawCopySign")] != -1);
		return scall<R>("rawCopySign", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto scalb(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("scalb")] != -1);
		return scall<R>("scalb", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto signum(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("signum")] != -1);
		return scall<R>("signum", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	static auto ulp(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("ulp")] != -1);
		return scall<R>("ulp", std::forward<Args>(args)...);
	}

};

#endif
