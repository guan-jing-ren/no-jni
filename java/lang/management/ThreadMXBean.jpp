#ifndef java_lang_management_ThreadMXBean_HPP
#define java_lang_management_ThreadMXBean_HPP

#include "../../../jfwd_decl.hpp"

class ::java::lang::management::ThreadMXBean : public jObject<::java::lang::management::ThreadMXBean, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_lang_management / "ThreadMXBean";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::lang::management::ThreadInfo *(::jboolean, ::jboolean)>("dumpAllThreads"), //
		jMethod<::jlong *()>("findDeadlockedThreads"), //
		jMethod<::jlong *()>("findMonitorDeadlockedThreads"), //
		jMethod<::jlong *()>("getAllThreadIds"), //
		jMethod<::jlong()>("getCurrentThreadCpuTime"), //
		jMethod<::jlong()>("getCurrentThreadUserTime"), //
		jMethod<::jint()>("getDaemonThreadCount"), //
		jMethod<::javax::management::ObjectName()>("getObjectName"), //
		jMethod<::jint()>("getPeakThreadCount"), //
		jMethod<::jint()>("getThreadCount"), //
		jMethod<::jlong(::jlong)>("getThreadCpuTime"), //
		jMethod<::java::lang::management::ThreadInfo(::jlong)>("getThreadInfo"), //
		jMethod<::java::lang::management::ThreadInfo(::jlong, ::jint)>("getThreadInfo"), //
		jMethod<::java::lang::management::ThreadInfo *(::jlong *)>("getThreadInfo"), //
		jMethod<::java::lang::management::ThreadInfo *(::jlong *, ::jint)>("getThreadInfo"), //
		jMethod<::java::lang::management::ThreadInfo *(::jlong *, ::jboolean, ::jboolean)>("getThreadInfo"), //
		jMethod<::jlong(::jlong)>("getThreadUserTime"), //
		jMethod<::jlong()>("getTotalStartedThreadCount"), //
		jMethod<::jboolean()>("isCurrentThreadCpuTimeSupported"), //
		jMethod<::jboolean()>("isObjectMonitorUsageSupported"), //
		jMethod<::jboolean()>("isSynchronizerUsageSupported"), //
		jMethod<::jboolean()>("isThreadContentionMonitoringEnabled"), //
		jMethod<::jboolean()>("isThreadContentionMonitoringSupported"), //
		jMethod<::jboolean()>("isThreadCpuTimeEnabled"), //
		jMethod<::jboolean()>("isThreadCpuTimeSupported"), //
		jMethod<::jvoid()>("resetPeakThreadCount"), //
		jMethod<::jvoid(::jboolean)>("setThreadContentionMonitoringEnabled"), //
		jMethod<::jvoid(::jboolean)>("setThreadCpuTimeEnabled"), //
	};

	template<typename R = ::java::lang::management::ThreadInfo *, typename... Args>
	auto dumpAllThreads(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("dumpAllThreads")] != -1);
		return call<R>("dumpAllThreads", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong *, typename... Args>
	auto findDeadlockedThreads(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findDeadlockedThreads")] != -1);
		return call<R>("findDeadlockedThreads", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong *, typename... Args>
	auto findMonitorDeadlockedThreads(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findMonitorDeadlockedThreads")] != -1);
		return call<R>("findMonitorDeadlockedThreads", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong *, typename... Args>
	auto getAllThreadIds(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getAllThreadIds")] != -1);
		return call<R>("getAllThreadIds", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getCurrentThreadCpuTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getCurrentThreadCpuTime")] != -1);
		return call<R>("getCurrentThreadCpuTime", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getCurrentThreadUserTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getCurrentThreadUserTime")] != -1);
		return call<R>("getCurrentThreadUserTime", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getDaemonThreadCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDaemonThreadCount")] != -1);
		return call<R>("getDaemonThreadCount", std::forward<Args>(args)...);
	}

	template<typename R = ::javax::management::ObjectName, typename... Args>
	auto getObjectName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getObjectName")] != -1);
		return call<R>("getObjectName", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getPeakThreadCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getPeakThreadCount")] != -1);
		return call<R>("getPeakThreadCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getThreadCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getThreadCount")] != -1);
		return call<R>("getThreadCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getThreadCpuTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getThreadCpuTime")] != -1);
		return call<R>("getThreadCpuTime", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::management::ThreadInfo, typename... Args>
	auto getThreadInfo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getThreadInfo")] != -1);
		return call<R>("getThreadInfo", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getThreadUserTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getThreadUserTime")] != -1);
		return call<R>("getThreadUserTime", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getTotalStartedThreadCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTotalStartedThreadCount")] != -1);
		return call<R>("getTotalStartedThreadCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isCurrentThreadCpuTimeSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isCurrentThreadCpuTimeSupported")] != -1);
		return call<R>("isCurrentThreadCpuTimeSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isObjectMonitorUsageSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isObjectMonitorUsageSupported")] != -1);
		return call<R>("isObjectMonitorUsageSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isSynchronizerUsageSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isSynchronizerUsageSupported")] != -1);
		return call<R>("isSynchronizerUsageSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isThreadContentionMonitoringEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isThreadContentionMonitoringEnabled")] != -1);
		return call<R>("isThreadContentionMonitoringEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isThreadContentionMonitoringSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isThreadContentionMonitoringSupported")] != -1);
		return call<R>("isThreadContentionMonitoringSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isThreadCpuTimeEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isThreadCpuTimeEnabled")] != -1);
		return call<R>("isThreadCpuTimeEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isThreadCpuTimeSupported(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isThreadCpuTimeSupported")] != -1);
		return call<R>("isThreadCpuTimeSupported", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto resetPeakThreadCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("resetPeakThreadCount")] != -1);
		return call<R>("resetPeakThreadCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setThreadContentionMonitoringEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setThreadContentionMonitoringEnabled")] != -1);
		return call<R>("setThreadContentionMonitoringEnabled", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setThreadCpuTimeEnabled(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setThreadCpuTimeEnabled")] != -1);
		return call<R>("setThreadCpuTimeEnabled", std::forward<Args>(args)...);
	}

};

#endif
