#ifndef java_util_regex_Matcher_HPP
#define java_util_regex_Matcher_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::regex::Matcher : public jObject<::java::util::regex::Matcher, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_regex / "Matcher";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::util::regex::Matcher(::java::lang::StringBuffer, ::java::lang::String)>("appendReplacement"), //
		jMethod<::java::lang::StringBuffer(::java::lang::StringBuffer)>("appendTail"), //
		jMethod<::jint()>("end"), //
		jMethod<::jint(::jint)>("end"), //
		jMethod<::jint(::java::lang::String)>("end"), //
		jMethod<::jboolean()>("find"), //
		jMethod<::jboolean(::jint)>("find"), //
		jMethod<::java::lang::String()>("group"), //
		jMethod<::java::lang::String(::jint)>("group"), //
		jMethod<::java::lang::String(::java::lang::String)>("group"), //
		jMethod<::jint()>("groupCount"), //
		jMethod<::jboolean()>("hasAnchoringBounds"), //
		jMethod<::jboolean()>("hasTransparentBounds"), //
		jMethod<::jboolean()>("hitEnd"), //
		jMethod<::jboolean()>("lookingAt"), //
		jMethod<::jboolean()>("matches"), //
		jMethod<::java::util::regex::Pattern()>("pattern"), //
		jMethod<::java::lang::String(::java::lang::String)>("quoteReplacement"), //
		jMethod<::java::util::regex::Matcher(::jint, ::jint)>("region"), //
		jMethod<::jint()>("regionEnd"), //
		jMethod<::jint()>("regionStart"), //
		jMethod<::java::lang::String(::java::lang::String)>("replaceAll"), //
		jMethod<::java::lang::String(::java::lang::String)>("replaceFirst"), //
		jMethod<::jboolean()>("requireEnd"), //
		jMethod<::java::util::regex::Matcher()>("reset"), //
		jMethod<::java::util::regex::Matcher(::java::lang::CharSequence)>("reset"), //
		jMethod<::jint()>("start"), //
		jMethod<::jint(::jint)>("start"), //
		jMethod<::jint(::java::lang::String)>("start"), //
		jMethod<::java::util::regex::MatchResult()>("toMatchResult"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::java::util::regex::Matcher(::jboolean)>("useAnchoringBounds"), //
		jMethod<::java::util::regex::Matcher(::java::util::regex::Pattern)>("usePattern"), //
		jMethod<::java::util::regex::Matcher(::jboolean)>("useTransparentBounds"), //
	};

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto appendReplacement(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("appendReplacement")] != -1);
		return call<R>("appendReplacement", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::StringBuffer, typename... Args>
	auto appendTail(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("appendTail")] != -1);
		return call<R>("appendTail", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto end(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("end")] != -1);
		return call<R>("end", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto find(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("find")] != -1);
		return call<R>("find", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto group(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("group")] != -1);
		return call<R>("group", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto groupCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("groupCount")] != -1);
		return call<R>("groupCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasAnchoringBounds(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasAnchoringBounds")] != -1);
		return call<R>("hasAnchoringBounds", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasTransparentBounds(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasTransparentBounds")] != -1);
		return call<R>("hasTransparentBounds", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hitEnd(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hitEnd")] != -1);
		return call<R>("hitEnd", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto lookingAt(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("lookingAt")] != -1);
		return call<R>("lookingAt", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto matches(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("matches")] != -1);
		return call<R>("matches", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Pattern, typename... Args>
	auto pattern(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("pattern")] != -1);
		return call<R>("pattern", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	static auto quoteReplacement(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("quoteReplacement")] != -1);
		return scall<R>("quoteReplacement", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto region(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("region")] != -1);
		return call<R>("region", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto regionEnd(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("regionEnd")] != -1);
		return call<R>("regionEnd", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto regionStart(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("regionStart")] != -1);
		return call<R>("regionStart", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto replaceAll(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("replaceAll")] != -1);
		return call<R>("replaceAll", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto replaceFirst(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("replaceFirst")] != -1);
		return call<R>("replaceFirst", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto requireEnd(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("requireEnd")] != -1);
		return call<R>("requireEnd", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto reset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reset")] != -1);
		return call<R>("reset", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto start(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("start")] != -1);
		return call<R>("start", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::MatchResult, typename... Args>
	auto toMatchResult(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toMatchResult")] != -1);
		return call<R>("toMatchResult", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto useAnchoringBounds(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useAnchoringBounds")] != -1);
		return call<R>("useAnchoringBounds", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto usePattern(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("usePattern")] != -1);
		return call<R>("usePattern", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Matcher, typename... Args>
	auto useTransparentBounds(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useTransparentBounds")] != -1);
		return call<R>("useTransparentBounds", std::forward<Args>(args)...);
	}

};

#endif
