#ifndef java_util_concurrent_Phaser_HPP
#define java_util_concurrent_Phaser_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::concurrent::Phaser : public jObject<::java::util::concurrent::Phaser, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_concurrent / "Phaser";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jConstructor<::jvoid(::jint)>(), //
		jConstructor<::jvoid(::java::util::concurrent::Phaser)>(), //
		jConstructor<::jvoid(::java::util::concurrent::Phaser, ::jint)>(), //
		jMethod<::jint()>("arrive"), //
		jMethod<::jint()>("arriveAndAwaitAdvance"), //
		jMethod<::jint()>("arriveAndDeregister"), //
		jMethod<::jint(::jint)>("awaitAdvance"), //
		jMethod<::jint(::jint)>("awaitAdvanceInterruptibly"), //
		jMethod<::jint(::jint, ::jlong, ::java::util::concurrent::TimeUnit)>("awaitAdvanceInterruptibly"), //
		jMethod<::jint(::jint)>("bulkRegister"), //
		jMethod<::jvoid()>("forceTermination"), //
		jMethod<::jint()>("getArrivedParties"), //
		jMethod<::java::util::concurrent::Phaser()>("getParent"), //
		jMethod<::jint()>("getPhase"), //
		jMethod<::jint()>("getRegisteredParties"), //
		jMethod<::java::util::concurrent::Phaser()>("getRoot"), //
		jMethod<::jint()>("getUnarrivedParties"), //
		jMethod<::jboolean()>("isTerminated"), //
		jMethod<::jint()>("register"), //
		jMethod<::java::lang::String()>("toString"), //
	};

	template<typename R = ::jint, typename... Args>
	auto arrive(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("arrive")] != -1);
		return call<R>("arrive", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto arriveAndAwaitAdvance(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("arriveAndAwaitAdvance")] != -1);
		return call<R>("arriveAndAwaitAdvance", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto arriveAndDeregister(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("arriveAndDeregister")] != -1);
		return call<R>("arriveAndDeregister", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto awaitAdvance(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("awaitAdvance")] != -1);
		return call<R>("awaitAdvance", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto awaitAdvanceInterruptibly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("awaitAdvanceInterruptibly")] != -1);
		return call<R>("awaitAdvanceInterruptibly", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto bulkRegister(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("bulkRegister")] != -1);
		return call<R>("bulkRegister", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto forceTermination(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("forceTermination")] != -1);
		return call<R>("forceTermination", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getArrivedParties(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getArrivedParties")] != -1);
		return call<R>("getArrivedParties", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::Phaser, typename... Args>
	auto getParent(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getParent")] != -1);
		return call<R>("getParent", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getPhase(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getPhase")] != -1);
		return call<R>("getPhase", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getRegisteredParties(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRegisteredParties")] != -1);
		return call<R>("getRegisteredParties", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::Phaser, typename... Args>
	auto getRoot(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRoot")] != -1);
		return call<R>("getRoot", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getUnarrivedParties(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getUnarrivedParties")] != -1);
		return call<R>("getUnarrivedParties", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isTerminated(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isTerminated")] != -1);
		return call<R>("isTerminated", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto register_(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("register")] != -1);
		return call<R>("register", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

};

#endif
