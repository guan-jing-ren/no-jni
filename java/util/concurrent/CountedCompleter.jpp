#ifndef java_util_concurrent_CountedCompleter_HPP
#define java_util_concurrent_CountedCompleter_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::concurrent::CountedCompleter : public jObject<::java::util::concurrent::CountedCompleter, ::java::util::concurrent::ForkJoinTask> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_concurrent / "CountedCompleter";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jvoid(::jint)>("addToPendingCount"), //
		jMethod<::jboolean(::jint, ::jint)>("compareAndSetPendingCount"), //
		jMethod<::jvoid(::java::lang::Object)>("complete"), //
		jMethod<::jvoid()>("compute"), //
		jMethod<::jint()>("decrementPendingCountUnlessZero"), //
		jMethod<::java::util::concurrent::CountedCompleter()>("firstComplete"), //
		jMethod<::java::util::concurrent::CountedCompleter()>("getCompleter"), //
		jMethod<::jint()>("getPendingCount"), //
		jMethod<::java::lang::Object()>("getRawResult"), //
		jMethod<::java::util::concurrent::CountedCompleter()>("getRoot"), //
		jMethod<::jvoid(::jint)>("helpComplete"), //
		jMethod<::java::util::concurrent::CountedCompleter()>("nextComplete"), //
		jMethod<::jvoid(::java::util::concurrent::CountedCompleter)>("onCompletion"), //
		jMethod<::jboolean(::java::lang::Throwable, ::java::util::concurrent::CountedCompleter)>("onExceptionalCompletion"), //
		jMethod<::jvoid()>("propagateCompletion"), //
		jMethod<::jvoid()>("quietlyCompleteRoot"), //
		jMethod<::jvoid(::jint)>("setPendingCount"), //
		jMethod<::jvoid()>("tryComplete"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto addToPendingCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("addToPendingCount")] != -1);
		return call<R>("addToPendingCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto compareAndSetPendingCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("compareAndSetPendingCount")] != -1);
		return call<R>("compareAndSetPendingCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto complete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("complete")] != -1);
		return call<R>("complete", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto compute(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("compute")] != -1);
		return call<R>("compute", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto decrementPendingCountUnlessZero(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("decrementPendingCountUnlessZero")] != -1);
		return call<R>("decrementPendingCountUnlessZero", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CountedCompleter, typename... Args>
	auto firstComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("firstComplete")] != -1);
		return call<R>("firstComplete", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CountedCompleter, typename... Args>
	auto getCompleter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getCompleter")] != -1);
		return call<R>("getCompleter", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getPendingCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getPendingCount")] != -1);
		return call<R>("getPendingCount", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	auto getRawResult(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRawResult")] != -1);
		return call<R>("getRawResult", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CountedCompleter, typename... Args>
	auto getRoot(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getRoot")] != -1);
		return call<R>("getRoot", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto helpComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("helpComplete")] != -1);
		return call<R>("helpComplete", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CountedCompleter, typename... Args>
	auto nextComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextComplete")] != -1);
		return call<R>("nextComplete", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto onCompletion(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("onCompletion")] != -1);
		return call<R>("onCompletion", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto onExceptionalCompletion(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("onExceptionalCompletion")] != -1);
		return call<R>("onExceptionalCompletion", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto propagateCompletion(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("propagateCompletion")] != -1);
		return call<R>("propagateCompletion", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto quietlyCompleteRoot(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("quietlyCompleteRoot")] != -1);
		return call<R>("quietlyCompleteRoot", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setPendingCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setPendingCount")] != -1);
		return call<R>("setPendingCount", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto tryComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("tryComplete")] != -1);
		return call<R>("tryComplete", std::forward<Args>(args)...);
	}

};

#endif
