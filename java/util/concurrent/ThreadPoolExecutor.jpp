#ifndef java_util_concurrent_ThreadPoolExecutor_HPP
#define java_util_concurrent_ThreadPoolExecutor_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::concurrent::ThreadPoolExecutor : public jObject<::java::util::concurrent::ThreadPoolExecutor, ::java::util::concurrent::AbstractExecutorService> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_concurrent / "ThreadPoolExecutor";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid(::jint, ::jint, ::jlong, ::java::util::concurrent::TimeUnit, ::java::util::concurrent::BlockingQueue)>(), //
		jConstructor<::jvoid(::jint, ::jint, ::jlong, ::java::util::concurrent::TimeUnit, ::java::util::concurrent::BlockingQueue, ::java::util::concurrent::RejectedExecutionHandler)>(), //
		jConstructor<::jvoid(::jint, ::jint, ::jlong, ::java::util::concurrent::TimeUnit, ::java::util::concurrent::BlockingQueue, ::java::util::concurrent::ThreadFactory)>(), //
		jConstructor<::jvoid(::jint, ::jint, ::jlong, ::java::util::concurrent::TimeUnit, ::java::util::concurrent::BlockingQueue, ::java::util::concurrent::ThreadFactory, ::java::util::concurrent::RejectedExecutionHandler)>(), //
		jMethod<::jvoid(::jboolean)>("allowCoreThreadTimeOut"), //
		jMethod<::jboolean()>("allowsCoreThreadTimeOut"), //
		jMethod<::jboolean(::jlong, ::java::util::concurrent::TimeUnit)>("awaitTermination"), //
		jMethod<::jvoid(::java::lang::Runnable)>("execute"), //
		jMethod<::jint()>("getActiveCount"), //
		jMethod<::jlong()>("getCompletedTaskCount"), //
		jMethod<::jint()>("getCorePoolSize"), //
		jMethod<::jlong(::java::util::concurrent::TimeUnit)>("getKeepAliveTime"), //
		jMethod<::jint()>("getLargestPoolSize"), //
		jMethod<::jint()>("getMaximumPoolSize"), //
		jMethod<::jint()>("getPoolSize"), //
		jMethod<::java::util::concurrent::BlockingQueue()>("getQueue"), //
		jMethod<::java::util::concurrent::RejectedExecutionHandler()>("getRejectedExecutionHandler"), //
		jMethod<::jlong()>("getTaskCount"), //
		jMethod<::java::util::concurrent::ThreadFactory()>("getThreadFactory"), //
		jMethod<::jboolean()>("isShutdown"), //
		jMethod<::jboolean()>("isTerminated"), //
		jMethod<::jboolean()>("isTerminating"), //
		jMethod<::jint()>("prestartAllCoreThreads"), //
		jMethod<::jboolean()>("prestartCoreThread"), //
		jMethod<::jvoid()>("purge"), //
		jMethod<::jboolean(::java::lang::Runnable)>("remove"), //
		jMethod<::jvoid(::jint)>("setCorePoolSize"), //
		jMethod<::jvoid(::jlong, ::java::util::concurrent::TimeUnit)>("setKeepAliveTime"), //
		jMethod<::jvoid(::jint)>("setMaximumPoolSize"), //
		jMethod<::jvoid(::java::util::concurrent::RejectedExecutionHandler)>("setRejectedExecutionHandler"), //
		jMethod<::jvoid(::java::util::concurrent::ThreadFactory)>("setThreadFactory"), //
		jMethod<::jvoid()>("shutdown"), //
		jMethod<::java::util::List()>("shutdownNow"), //
		jMethod<::java::lang::String()>("toString"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto allowCoreThreadTimeOut(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("allowCoreThreadTimeOut")] != -1);
		return call<R>("allowCoreThreadTimeOut", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto allowsCoreThreadTimeOut(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("allowsCoreThreadTimeOut")] != -1);
		return call<R>("allowsCoreThreadTimeOut", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto awaitTermination(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("awaitTermination")] != -1);
		return call<R>("awaitTermination", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto execute(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("execute")] != -1);
		return call<R>("execute", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getActiveCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getActiveCount")] != -1);
		return call<R>("getActiveCount", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getCompletedTaskCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getCompletedTaskCount")] != -1);
		return call<R>("getCompletedTaskCount", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getCorePoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getCorePoolSize")] != -1);
		return call<R>("getCorePoolSize", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getKeepAliveTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getKeepAliveTime")] != -1);
		return call<R>("getKeepAliveTime", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getLargestPoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getLargestPoolSize")] != -1);
		return call<R>("getLargestPoolSize", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getMaximumPoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getMaximumPoolSize")] != -1);
		return call<R>("getMaximumPoolSize", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getPoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getPoolSize")] != -1);
		return call<R>("getPoolSize", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::BlockingQueue, typename... Args>
	auto getQueue(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getQueue")] != -1);
		return call<R>("getQueue", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::RejectedExecutionHandler, typename... Args>
	auto getRejectedExecutionHandler(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getRejectedExecutionHandler")] != -1);
		return call<R>("getRejectedExecutionHandler", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto getTaskCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getTaskCount")] != -1);
		return call<R>("getTaskCount", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::ThreadFactory, typename... Args>
	auto getThreadFactory(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getThreadFactory")] != -1);
		return call<R>("getThreadFactory", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isShutdown(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isShutdown")] != -1);
		return call<R>("isShutdown", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isTerminated(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isTerminated")] != -1);
		return call<R>("isTerminated", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isTerminating(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isTerminating")] != -1);
		return call<R>("isTerminating", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto prestartAllCoreThreads(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("prestartAllCoreThreads")] != -1);
		return call<R>("prestartAllCoreThreads", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto prestartCoreThread(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("prestartCoreThread")] != -1);
		return call<R>("prestartCoreThread", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto purge(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("purge")] != -1);
		return call<R>("purge", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto remove(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("remove")] != -1);
		return call<R>("remove", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setCorePoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("setCorePoolSize")] != -1);
		return call<R>("setCorePoolSize", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setKeepAliveTime(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("setKeepAliveTime")] != -1);
		return call<R>("setKeepAliveTime", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setMaximumPoolSize(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("setMaximumPoolSize")] != -1);
		return call<R>("setMaximumPoolSize", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setRejectedExecutionHandler(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("setRejectedExecutionHandler")] != -1);
		return call<R>("setRejectedExecutionHandler", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setThreadFactory(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("setThreadFactory")] != -1);
		return call<R>("setThreadFactory", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto shutdown(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("shutdown")] != -1);
		return call<R>("shutdown", forward<Args>(args)...);
	}

	template<typename R = ::java::util::List, typename... Args>
	auto shutdownNow(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("shutdownNow")] != -1);
		return call<R>("shutdownNow", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", forward<Args>(args)...);
	}

};

#endif
