#ifndef java_util_concurrent_CompletionStage_HPP
#define java_util_concurrent_CompletionStage_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::concurrent::CompletionStage : public jObject<::java::util::concurrent::CompletionStage, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_concurrent / "CompletionStage";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Consumer)>("acceptEither"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Consumer)>("acceptEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Consumer, ::java::util::concurrent::Executor)>("acceptEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Function)>("applyToEither"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Function)>("applyToEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::Function, ::java::util::concurrent::Executor)>("applyToEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function)>("exceptionally"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiFunction)>("handle"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiFunction)>("handleAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiFunction, ::java::util::concurrent::Executor)>("handleAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable)>("runAfterBoth"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable)>("runAfterBothAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable, ::java::util::concurrent::Executor)>("runAfterBothAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable)>("runAfterEither"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable)>("runAfterEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::lang::Runnable, ::java::util::concurrent::Executor)>("runAfterEitherAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Consumer)>("thenAccept"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Consumer)>("thenAcceptAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Consumer, ::java::util::concurrent::Executor)>("thenAcceptAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiConsumer)>("thenAcceptBoth"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiConsumer)>("thenAcceptBothAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiConsumer, ::java::util::concurrent::Executor)>("thenAcceptBothAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function)>("thenApply"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function)>("thenApplyAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function, ::java::util::concurrent::Executor)>("thenApplyAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiFunction)>("thenCombine"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiFunction)>("thenCombineAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::concurrent::CompletionStage, ::java::util::function::BiFunction, ::java::util::concurrent::Executor)>("thenCombineAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function)>("thenCompose"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function)>("thenComposeAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::Function, ::java::util::concurrent::Executor)>("thenComposeAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::lang::Runnable)>("thenRun"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::lang::Runnable)>("thenRunAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::lang::Runnable, ::java::util::concurrent::Executor)>("thenRunAsync"), //
		jMethod<::java::util::concurrent::CompletableFuture()>("toCompletableFuture"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiConsumer)>("whenComplete"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiConsumer)>("whenCompleteAsync"), //
		jMethod<::java::util::concurrent::CompletionStage(::java::util::function::BiConsumer, ::java::util::concurrent::Executor)>("whenCompleteAsync"), //
	};

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto acceptEither(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("acceptEither")] != -1);
		return call<R>("acceptEither", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto acceptEitherAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("acceptEitherAsync")] != -1);
		return call<R>("acceptEitherAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto applyToEither(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("applyToEither")] != -1);
		return call<R>("applyToEither", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto applyToEitherAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("applyToEitherAsync")] != -1);
		return call<R>("applyToEitherAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto exceptionally(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("exceptionally")] != -1);
		return call<R>("exceptionally", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto handle(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("handle")] != -1);
		return call<R>("handle", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto handleAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("handleAsync")] != -1);
		return call<R>("handleAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto runAfterBoth(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("runAfterBoth")] != -1);
		return call<R>("runAfterBoth", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto runAfterBothAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("runAfterBothAsync")] != -1);
		return call<R>("runAfterBothAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto runAfterEither(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("runAfterEither")] != -1);
		return call<R>("runAfterEither", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto runAfterEitherAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("runAfterEitherAsync")] != -1);
		return call<R>("runAfterEitherAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenAccept(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenAccept")] != -1);
		return call<R>("thenAccept", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenAcceptAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenAcceptAsync")] != -1);
		return call<R>("thenAcceptAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenAcceptBoth(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenAcceptBoth")] != -1);
		return call<R>("thenAcceptBoth", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenAcceptBothAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenAcceptBothAsync")] != -1);
		return call<R>("thenAcceptBothAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenApply(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenApply")] != -1);
		return call<R>("thenApply", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenApplyAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenApplyAsync")] != -1);
		return call<R>("thenApplyAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenCombine(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenCombine")] != -1);
		return call<R>("thenCombine", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenCombineAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenCombineAsync")] != -1);
		return call<R>("thenCombineAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenCompose(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenCompose")] != -1);
		return call<R>("thenCompose", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenComposeAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenComposeAsync")] != -1);
		return call<R>("thenComposeAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenRun(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenRun")] != -1);
		return call<R>("thenRun", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto thenRunAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("thenRunAsync")] != -1);
		return call<R>("thenRunAsync", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletableFuture, typename... Args>
	auto toCompletableFuture(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("toCompletableFuture")] != -1);
		return call<R>("toCompletableFuture", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto whenComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("whenComplete")] != -1);
		return call<R>("whenComplete", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::CompletionStage, typename... Args>
	auto whenCompleteAsync(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("whenCompleteAsync")] != -1);
		return call<R>("whenCompleteAsync", forward<Args>(args)...);
	}

};

#endif
