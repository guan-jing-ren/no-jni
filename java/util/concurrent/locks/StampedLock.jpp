#ifndef java_util_concurrent_locks_StampedLock_HPP
#define java_util_concurrent_locks_StampedLock_HPP

#include "../../../../jfwd_decl.hpp"

class ::java::util::concurrent::locks::StampedLock : public jObject<::java::util::concurrent::locks::StampedLock, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_concurrent_locks / "StampedLock";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid()>(), //
		jMethod<::java::util::concurrent::locks::Lock()>("asReadLock"), //
		jMethod<::java::util::concurrent::locks::ReadWriteLock()>("asReadWriteLock"), //
		jMethod<::java::util::concurrent::locks::Lock()>("asWriteLock"), //
		jMethod<::jint()>("getReadLockCount"), //
		jMethod<::jboolean()>("isReadLocked"), //
		jMethod<::jboolean()>("isWriteLocked"), //
		jMethod<::jlong()>("readLock"), //
		jMethod<::jlong()>("readLockInterruptibly"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::jlong(::jlong)>("tryConvertToOptimisticRead"), //
		jMethod<::jlong(::jlong)>("tryConvertToReadLock"), //
		jMethod<::jlong(::jlong)>("tryConvertToWriteLock"), //
		jMethod<::jlong()>("tryOptimisticRead"), //
		jMethod<::jlong()>("tryReadLock"), //
		jMethod<::jlong(::jlong, ::java::util::concurrent::TimeUnit)>("tryReadLock"), //
		jMethod<::jboolean()>("tryUnlockRead"), //
		jMethod<::jboolean()>("tryUnlockWrite"), //
		jMethod<::jlong()>("tryWriteLock"), //
		jMethod<::jlong(::jlong, ::java::util::concurrent::TimeUnit)>("tryWriteLock"), //
		jMethod<::jvoid(::jlong)>("unlock"), //
		jMethod<::jvoid(::jlong)>("unlockRead"), //
		jMethod<::jvoid(::jlong)>("unlockWrite"), //
		jMethod<::jboolean(::jlong)>("validate"), //
		jMethod<::jlong()>("writeLock"), //
		jMethod<::jlong()>("writeLockInterruptibly"), //
	};

	template<typename R = ::java::util::concurrent::locks::Lock, typename... Args>
	auto asReadLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("asReadLock")] != -1);
		return call<R>("asReadLock", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::locks::ReadWriteLock, typename... Args>
	auto asReadWriteLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("asReadWriteLock")] != -1);
		return call<R>("asReadWriteLock", forward<Args>(args)...);
	}

	template<typename R = ::java::util::concurrent::locks::Lock, typename... Args>
	auto asWriteLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("asWriteLock")] != -1);
		return call<R>("asWriteLock", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getReadLockCount(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("getReadLockCount")] != -1);
		return call<R>("getReadLockCount", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isReadLocked(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isReadLocked")] != -1);
		return call<R>("isReadLocked", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isWriteLocked(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isWriteLocked")] != -1);
		return call<R>("isWriteLocked", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto readLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("readLock")] != -1);
		return call<R>("readLock", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto readLockInterruptibly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("readLockInterruptibly")] != -1);
		return call<R>("readLockInterruptibly", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryConvertToOptimisticRead(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryConvertToOptimisticRead")] != -1);
		return call<R>("tryConvertToOptimisticRead", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryConvertToReadLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryConvertToReadLock")] != -1);
		return call<R>("tryConvertToReadLock", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryConvertToWriteLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryConvertToWriteLock")] != -1);
		return call<R>("tryConvertToWriteLock", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryOptimisticRead(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryOptimisticRead")] != -1);
		return call<R>("tryOptimisticRead", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryReadLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryReadLock")] != -1);
		return call<R>("tryReadLock", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto tryUnlockRead(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryUnlockRead")] != -1);
		return call<R>("tryUnlockRead", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto tryUnlockWrite(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryUnlockWrite")] != -1);
		return call<R>("tryUnlockWrite", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto tryWriteLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("tryWriteLock")] != -1);
		return call<R>("tryWriteLock", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unlock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("unlock")] != -1);
		return call<R>("unlock", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unlockRead(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("unlockRead")] != -1);
		return call<R>("unlockRead", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto unlockWrite(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("unlockWrite")] != -1);
		return call<R>("unlockWrite", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto validate(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("validate")] != -1);
		return call<R>("validate", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto writeLock(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("writeLock")] != -1);
		return call<R>("writeLock", forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto writeLockInterruptibly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("writeLockInterruptibly")] != -1);
		return call<R>("writeLockInterruptibly", forward<Args>(args)...);
	}

};

#endif
