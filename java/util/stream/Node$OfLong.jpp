#ifndef java_util_stream_Node$OfLong_HPP
#define java_util_stream_Node$OfLong_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::stream::Node$OfLong : public jObject<::java::util::stream::Node$OfLong, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_stream / "Node$OfLong";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::lang::Object()>("asPrimitiveArray"), //
		jMethod<::jvoid(::java::lang::Object, ::jint)>("copyInto"), //
		jMethod<::jvoid(::java::lang::Long *, ::jint)>("copyInto"), //
		jMethod<::jvoid(::java::lang::Object *, ::jint)>("copyInto"), //
		jMethod<::jlong()>("count"), //
		jMethod<::jvoid(::java::lang::Object)>("forEach"), //
		jMethod<::jvoid(::java::util::function::Consumer)>("forEach"), //
		jMethod<::java::util::stream::StreamShape()>("getShape"), //
		jMethod<::java::lang::Object(::jint)>("newArray"), //
		jMethod<::jlong *(::jint)>("newArray"), //
		jMethod<::java::util::Spliterator$OfPrimitive()>("spliterator"), //
		jMethod<::java::util::stream::Node$OfLong(::jlong, ::jlong, ::java::util::function::IntFunction)>("truncate"), //
		jMethod<::java::util::stream::Node$OfPrimitive(::jlong, ::jlong, ::java::util::function::IntFunction)>("truncate"), //
		jMethod<::java::util::stream::Node(::jlong, ::jlong, ::java::util::function::IntFunction)>("truncate"), //
	};

	template<typename R = ::java::lang::Object, typename... Args>
	auto asPrimitiveArray(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("asPrimitiveArray")] != -1);
		return call<R>("asPrimitiveArray", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto copyInto(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("copyInto")] != -1);
		return call<R>("copyInto", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto count(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("count")] != -1);
		return call<R>("count", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto forEach(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("forEach")] != -1);
		return call<R>("forEach", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::StreamShape, typename... Args>
	auto getShape(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getShape")] != -1);
		return call<R>("getShape", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	auto newArray(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("newArray")] != -1);
		return call<R>("newArray", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Spliterator$OfPrimitive, typename... Args>
	auto spliterator(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("spliterator")] != -1);
		return call<R>("spliterator", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::Node$OfLong, typename... Args>
	auto truncate(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("truncate")] != -1);
		return call<R>("truncate", std::forward<Args>(args)...);
	}

};

#endif
