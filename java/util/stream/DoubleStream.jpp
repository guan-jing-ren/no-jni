#ifndef java_util_stream_DoubleStream_HPP
#define java_util_stream_DoubleStream_HPP

#include "../../../jfwd_decl.hpp"

class ::java::util::stream::DoubleStream : public jObject<::java::util::stream::DoubleStream, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util_stream / "DoubleStream";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jboolean(::java::util::function::DoublePredicate)>("allMatch"), //
		jMethod<::jboolean(::java::util::function::DoublePredicate)>("anyMatch"), //
		jMethod<::java::util::OptionalDouble()>("average"), //
		jMethod<::java::util::stream::Stream()>("boxed"), //
		jMethod<::java::util::stream::DoubleStream$Builder()>("builder"), //
		jMethod<::jvoid()>("close"), //
		jMethod<::java::lang::Object(::java::util::function::Supplier, ::java::util::function::ObjDoubleConsumer, ::java::util::function::BiConsumer)>("collect"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::stream::DoubleStream, ::java::util::stream::DoubleStream)>("concat"), //
		jMethod<::jlong()>("count"), //
		jMethod<::java::util::stream::DoubleStream()>("distinct"), //
		jMethod<::java::util::stream::DoubleStream()>("empty"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::function::DoublePredicate)>("filter"), //
		jMethod<::java::util::OptionalDouble()>("findAny"), //
		jMethod<::java::util::OptionalDouble()>("findFirst"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::function::DoubleFunction)>("flatMap"), //
		jMethod<::jvoid(::java::util::function::DoubleConsumer)>("forEach"), //
		jMethod<::jvoid(::java::util::function::DoubleConsumer)>("forEachOrdered"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::function::DoubleSupplier)>("generate"), //
		jMethod<::jboolean()>("isParallel"), //
		jMethod<::java::util::stream::DoubleStream(::jdouble, ::java::util::function::DoubleUnaryOperator)>("iterate"), //
		jMethod<::java::util::Iterator()>("iterator"), //
		jMethod<::java::util::PrimitiveIterator$OfDouble()>("iterator"), //
		jMethod<::java::util::stream::DoubleStream(::jlong)>("limit"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::function::DoubleUnaryOperator)>("map"), //
		jMethod<::java::util::stream::IntStream(::java::util::function::DoubleToIntFunction)>("mapToInt"), //
		jMethod<::java::util::stream::LongStream(::java::util::function::DoubleToLongFunction)>("mapToLong"), //
		jMethod<::java::util::stream::Stream(::java::util::function::DoubleFunction)>("mapToObj"), //
		jMethod<::java::util::OptionalDouble()>("max"), //
		jMethod<::java::util::OptionalDouble()>("min"), //
		jMethod<::jboolean(::java::util::function::DoublePredicate)>("noneMatch"), //
		jMethod<::java::util::stream::DoubleStream(::jdouble)>("of"), //
		jMethod<::java::util::stream::DoubleStream(::jdouble *)>("of"), //
		jMethod<::java::util::stream::BaseStream(::java::lang::Runnable)>("onClose"), //
		jMethod<::java::util::stream::BaseStream()>("parallel"), //
		jMethod<::java::util::stream::DoubleStream()>("parallel"), //
		jMethod<::java::util::stream::DoubleStream(::java::util::function::DoubleConsumer)>("peek"), //
		jMethod<::jdouble(::jdouble, ::java::util::function::DoubleBinaryOperator)>("reduce"), //
		jMethod<::java::util::OptionalDouble(::java::util::function::DoubleBinaryOperator)>("reduce"), //
		jMethod<::java::util::stream::BaseStream()>("sequential"), //
		jMethod<::java::util::stream::DoubleStream()>("sequential"), //
		jMethod<::java::util::stream::DoubleStream(::jlong)>("skip"), //
		jMethod<::java::util::stream::DoubleStream()>("sorted"), //
		jMethod<::java::util::Spliterator$OfDouble()>("spliterator"), //
		jMethod<::java::util::Spliterator()>("spliterator"), //
		jMethod<::jdouble()>("sum"), //
		jMethod<::java::util::DoubleSummaryStatistics()>("summaryStatistics"), //
		jMethod<::jdouble *()>("toArray"), //
		jMethod<::java::util::stream::BaseStream()>("unordered"), //
	};

	template<typename R = ::jboolean, typename... Args>
	auto allMatch(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("allMatch")] != -1);
		return call<R>("allMatch", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto anyMatch(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("anyMatch")] != -1);
		return call<R>("anyMatch", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::OptionalDouble, typename... Args>
	auto average(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("average")] != -1);
		return call<R>("average", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::Stream, typename... Args>
	auto boxed(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("boxed")] != -1);
		return call<R>("boxed", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream$Builder, typename... Args>
	static auto builder(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("builder")] != -1);
		return scall<R>("builder", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto close(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("close")] != -1);
		return call<R>("close", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	auto collect(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("collect")] != -1);
		return call<R>("collect", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	static auto concat(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("concat")] != -1);
		return scall<R>("concat", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto count(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("count")] != -1);
		return call<R>("count", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto distinct(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("distinct")] != -1);
		return call<R>("distinct", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	static auto empty(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("empty")] != -1);
		return scall<R>("empty", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto filter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("filter")] != -1);
		return call<R>("filter", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::OptionalDouble, typename... Args>
	auto findAny(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findAny")] != -1);
		return call<R>("findAny", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::OptionalDouble, typename... Args>
	auto findFirst(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findFirst")] != -1);
		return call<R>("findFirst", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto flatMap(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("flatMap")] != -1);
		return call<R>("flatMap", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto forEach(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("forEach")] != -1);
		return call<R>("forEach", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto forEachOrdered(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("forEachOrdered")] != -1);
		return call<R>("forEachOrdered", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	static auto generate(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("generate")] != -1);
		return scall<R>("generate", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isParallel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isParallel")] != -1);
		return call<R>("isParallel", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	static auto iterate(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("iterate")] != -1);
		return scall<R>("iterate", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Iterator, typename... Args>
	auto iterator(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("iterator")] != -1);
		return call<R>("iterator", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto limit(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("limit")] != -1);
		return call<R>("limit", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto map(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("map")] != -1);
		return call<R>("map", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::IntStream, typename... Args>
	auto mapToInt(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("mapToInt")] != -1);
		return call<R>("mapToInt", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::LongStream, typename... Args>
	auto mapToLong(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("mapToLong")] != -1);
		return call<R>("mapToLong", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::Stream, typename... Args>
	auto mapToObj(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("mapToObj")] != -1);
		return call<R>("mapToObj", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::OptionalDouble, typename... Args>
	auto max(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("max")] != -1);
		return call<R>("max", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::OptionalDouble, typename... Args>
	auto min(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("min")] != -1);
		return call<R>("min", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto noneMatch(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("noneMatch")] != -1);
		return call<R>("noneMatch", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	static auto of(Args &&...args) {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("of")] != -1);
		return scall<R>("of", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::BaseStream, typename... Args>
	auto onClose(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("onClose")] != -1);
		return call<R>("onClose", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::BaseStream, typename... Args>
	auto parallel(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("parallel")] != -1);
		return call<R>("parallel", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto peek(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("peek")] != -1);
		return call<R>("peek", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	auto reduce(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reduce")] != -1);
		return call<R>("reduce", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::BaseStream, typename... Args>
	auto sequential(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("sequential")] != -1);
		return call<R>("sequential", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto skip(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("skip")] != -1);
		return call<R>("skip", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::DoubleStream, typename... Args>
	auto sorted(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("sorted")] != -1);
		return call<R>("sorted", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Spliterator$OfDouble, typename... Args>
	auto spliterator(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("spliterator")] != -1);
		return call<R>("spliterator", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	auto sum(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("sum")] != -1);
		return call<R>("sum", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::DoubleSummaryStatistics, typename... Args>
	auto summaryStatistics(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("summaryStatistics")] != -1);
		return call<R>("summaryStatistics", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble *, typename... Args>
	auto toArray(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toArray")] != -1);
		return call<R>("toArray", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::stream::BaseStream, typename... Args>
	auto unordered(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("unordered")] != -1);
		return call<R>("unordered", std::forward<Args>(args)...);
	}

};

#endif
