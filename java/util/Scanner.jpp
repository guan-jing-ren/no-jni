#ifndef java_util_Scanner_HPP
#define java_util_Scanner_HPP

#include "../../jfwd_decl.hpp"

class ::java::util::Scanner : public jObject<::java::util::Scanner, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_util / "Scanner";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jConstructor<::jvoid(::java::io::File)>(), //
		jConstructor<::jvoid(::java::io::File, ::java::lang::String)>(), //
		jConstructor<::jvoid(::java::io::InputStream)>(), //
		jConstructor<::jvoid(::java::io::InputStream, ::java::lang::String)>(), //
		jConstructor<::jvoid(::java::lang::Readable)>(), //
		jConstructor<::jvoid(::java::lang::String)>(), //
		jConstructor<::jvoid(::java::nio::channels::ReadableByteChannel)>(), //
		jConstructor<::jvoid(::java::nio::channels::ReadableByteChannel, ::java::lang::String)>(), //
		jConstructor<::jvoid(::java::nio::file::Path)>(), //
		jConstructor<::jvoid(::java::nio::file::Path, ::java::lang::String)>(), //
		jMethod<::jvoid()>("close"), //
		jMethod<::java::util::regex::Pattern()>("delimiter"), //
		jMethod<::java::lang::String(::java::lang::String)>("findInLine"), //
		jMethod<::java::lang::String(::java::util::regex::Pattern)>("findInLine"), //
		jMethod<::java::lang::String(::java::lang::String, ::jint)>("findWithinHorizon"), //
		jMethod<::java::lang::String(::java::util::regex::Pattern, ::jint)>("findWithinHorizon"), //
		jMethod<::jboolean()>("hasNext"), //
		jMethod<::jboolean(::java::lang::String)>("hasNext"), //
		jMethod<::jboolean(::java::util::regex::Pattern)>("hasNext"), //
		jMethod<::jboolean()>("hasNextBigDecimal"), //
		jMethod<::jboolean()>("hasNextBigInteger"), //
		jMethod<::jboolean(::jint)>("hasNextBigInteger"), //
		jMethod<::jboolean()>("hasNextBoolean"), //
		jMethod<::jboolean()>("hasNextByte"), //
		jMethod<::jboolean(::jint)>("hasNextByte"), //
		jMethod<::jboolean()>("hasNextDouble"), //
		jMethod<::jboolean()>("hasNextFloat"), //
		jMethod<::jboolean()>("hasNextInt"), //
		jMethod<::jboolean(::jint)>("hasNextInt"), //
		jMethod<::jboolean()>("hasNextLine"), //
		jMethod<::jboolean()>("hasNextLong"), //
		jMethod<::jboolean(::jint)>("hasNextLong"), //
		jMethod<::jboolean()>("hasNextShort"), //
		jMethod<::jboolean(::jint)>("hasNextShort"), //
		jMethod<::java::io::IOException()>("ioException"), //
		jMethod<::java::util::Locale()>("locale"), //
		jMethod<::java::util::regex::MatchResult()>("match"), //
		jMethod<::java::lang::Object()>("next"), //
		jMethod<::java::lang::String()>("next"), //
		jMethod<::java::lang::String(::java::lang::String)>("next"), //
		jMethod<::java::lang::String(::java::util::regex::Pattern)>("next"), //
		jMethod<::java::math::BigDecimal()>("nextBigDecimal"), //
		jMethod<::java::math::BigInteger()>("nextBigInteger"), //
		jMethod<::java::math::BigInteger(::jint)>("nextBigInteger"), //
		jMethod<::jboolean()>("nextBoolean"), //
		jMethod<::jbyte()>("nextByte"), //
		jMethod<::jbyte(::jint)>("nextByte"), //
		jMethod<::jdouble()>("nextDouble"), //
		jMethod<::jfloat()>("nextFloat"), //
		jMethod<::jint()>("nextInt"), //
		jMethod<::jint(::jint)>("nextInt"), //
		jMethod<::java::lang::String()>("nextLine"), //
		jMethod<::jlong()>("nextLong"), //
		jMethod<::jlong(::jint)>("nextLong"), //
		jMethod<::jshort()>("nextShort"), //
		jMethod<::jshort(::jint)>("nextShort"), //
		jMethod<::jint()>("radix"), //
		jMethod<::jvoid()>("remove"), //
		jMethod<::java::util::Scanner()>("reset"), //
		jMethod<::java::util::Scanner(::java::lang::String)>("skip"), //
		jMethod<::java::util::Scanner(::java::util::regex::Pattern)>("skip"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::java::util::Scanner(::java::lang::String)>("useDelimiter"), //
		jMethod<::java::util::Scanner(::java::util::regex::Pattern)>("useDelimiter"), //
		jMethod<::java::util::Scanner(::java::util::Locale)>("useLocale"), //
		jMethod<::java::util::Scanner(::jint)>("useRadix"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto close(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("close")] != -1);
		return call<R>("close", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::Pattern, typename... Args>
	auto delimiter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("delimiter")] != -1);
		return call<R>("delimiter", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto findInLine(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findInLine")] != -1);
		return call<R>("findInLine", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto findWithinHorizon(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("findWithinHorizon")] != -1);
		return call<R>("findWithinHorizon", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNext(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNext")] != -1);
		return call<R>("hasNext", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextBigDecimal(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextBigDecimal")] != -1);
		return call<R>("hasNextBigDecimal", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextBigInteger(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextBigInteger")] != -1);
		return call<R>("hasNextBigInteger", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextBoolean(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextBoolean")] != -1);
		return call<R>("hasNextBoolean", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextByte(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextByte")] != -1);
		return call<R>("hasNextByte", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextDouble(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextDouble")] != -1);
		return call<R>("hasNextDouble", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextFloat(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextFloat")] != -1);
		return call<R>("hasNextFloat", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextInt(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextInt")] != -1);
		return call<R>("hasNextInt", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextLine(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextLine")] != -1);
		return call<R>("hasNextLine", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextLong(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextLong")] != -1);
		return call<R>("hasNextLong", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasNextShort(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasNextShort")] != -1);
		return call<R>("hasNextShort", std::forward<Args>(args)...);
	}

	template<typename R = ::java::io::IOException, typename... Args>
	auto ioException(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("ioException")] != -1);
		return call<R>("ioException", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Locale, typename... Args>
	auto locale(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("locale")] != -1);
		return call<R>("locale", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::regex::MatchResult, typename... Args>
	auto match(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("match")] != -1);
		return call<R>("match", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::Object, typename... Args>
	auto next(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("next")] != -1);
		return call<R>("next", std::forward<Args>(args)...);
	}

	template<typename R = ::java::math::BigDecimal, typename... Args>
	auto nextBigDecimal(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextBigDecimal")] != -1);
		return call<R>("nextBigDecimal", std::forward<Args>(args)...);
	}

	template<typename R = ::java::math::BigInteger, typename... Args>
	auto nextBigInteger(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextBigInteger")] != -1);
		return call<R>("nextBigInteger", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto nextBoolean(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextBoolean")] != -1);
		return call<R>("nextBoolean", std::forward<Args>(args)...);
	}

	template<typename R = ::jbyte, typename... Args>
	auto nextByte(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextByte")] != -1);
		return call<R>("nextByte", std::forward<Args>(args)...);
	}

	template<typename R = ::jdouble, typename... Args>
	auto nextDouble(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextDouble")] != -1);
		return call<R>("nextDouble", std::forward<Args>(args)...);
	}

	template<typename R = ::jfloat, typename... Args>
	auto nextFloat(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextFloat")] != -1);
		return call<R>("nextFloat", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto nextInt(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextInt")] != -1);
		return call<R>("nextInt", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto nextLine(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextLine")] != -1);
		return call<R>("nextLine", std::forward<Args>(args)...);
	}

	template<typename R = ::jlong, typename... Args>
	auto nextLong(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextLong")] != -1);
		return call<R>("nextLong", std::forward<Args>(args)...);
	}

	template<typename R = ::jshort, typename... Args>
	auto nextShort(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("nextShort")] != -1);
		return call<R>("nextShort", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto radix(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("radix")] != -1);
		return call<R>("radix", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto remove(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("remove")] != -1);
		return call<R>("remove", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Scanner, typename... Args>
	auto reset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reset")] != -1);
		return call<R>("reset", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Scanner, typename... Args>
	auto skip(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("skip")] != -1);
		return call<R>("skip", std::forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Scanner, typename... Args>
	auto useDelimiter(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useDelimiter")] != -1);
		return call<R>("useDelimiter", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Scanner, typename... Args>
	auto useLocale(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useLocale")] != -1);
		return call<R>("useLocale", std::forward<Args>(args)...);
	}

	template<typename R = ::java::util::Scanner, typename... Args>
	auto useRadix(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("useRadix")] != -1);
		return call<R>("useRadix", std::forward<Args>(args)...);
	}

};

#endif
