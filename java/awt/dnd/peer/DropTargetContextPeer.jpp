#ifndef java_awt_dnd_peer_DropTargetContextPeer_HPP
#define java_awt_dnd_peer_DropTargetContextPeer_HPP

#include "../../../../jfwd_decl.hpp"

class ::java::awt::dnd::peer::DropTargetContextPeer : public jObject<::java::awt::dnd::peer::DropTargetContextPeer, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_awt_dnd_peer / "DropTargetContextPeer";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::jvoid(::jint)>("acceptDrag"), //
		jMethod<::jvoid(::jint)>("acceptDrop"), //
		jMethod<::jvoid(::jboolean)>("dropComplete"), //
		jMethod<::java::awt::dnd::DropTarget()>("getDropTarget"), //
		jMethod<::jint()>("getTargetActions"), //
		jMethod<::java::awt::datatransfer::DataFlavor *()>("getTransferDataFlavors"), //
		jMethod<::java::awt::datatransfer::Transferable()>("getTransferable"), //
		jMethod<::jboolean()>("isTransferableJVMLocal"), //
		jMethod<::jvoid()>("rejectDrag"), //
		jMethod<::jvoid()>("rejectDrop"), //
		jMethod<::jvoid(::jint)>("setTargetActions"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto acceptDrag(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("acceptDrag")] != -1);
		return call<R>("acceptDrag", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto acceptDrop(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("acceptDrop")] != -1);
		return call<R>("acceptDrop", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto dropComplete(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("dropComplete")] != -1);
		return call<R>("dropComplete", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::dnd::DropTarget, typename... Args>
	auto getDropTarget(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getDropTarget")] != -1);
		return call<R>("getDropTarget", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto getTargetActions(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTargetActions")] != -1);
		return call<R>("getTargetActions", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::datatransfer::DataFlavor *, typename... Args>
	auto getTransferDataFlavors(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTransferDataFlavors")] != -1);
		return call<R>("getTransferDataFlavors", std::forward<Args>(args)...);
	}

	template<typename R = ::java::awt::datatransfer::Transferable, typename... Args>
	auto getTransferable(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("getTransferable")] != -1);
		return call<R>("getTransferable", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isTransferableJVMLocal(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isTransferableJVMLocal")] != -1);
		return call<R>("isTransferableJVMLocal", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto rejectDrag(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("rejectDrag")] != -1);
		return call<R>("rejectDrag", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto rejectDrop(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("rejectDrop")] != -1);
		return call<R>("rejectDrop", std::forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto setTargetActions(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("setTargetActions")] != -1);
		return call<R>("setTargetActions", std::forward<Args>(args)...);
	}

};

#endif
