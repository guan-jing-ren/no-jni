#ifndef java_nio_Buffer_HPP
#define java_nio_Buffer_HPP

#include "../../jfwd_decl.hpp"

class ::java::nio::Buffer : public jObject<::java::nio::Buffer, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_nio / "Buffer";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::lang::Object()>("array"), //
		jMethod<::jint()>("arrayOffset"), //
		jMethod<::jint()>("capacity"), //
		jMethod<::java::nio::Buffer()>("clear"), //
		jMethod<::java::nio::Buffer()>("flip"), //
		jMethod<::jboolean()>("hasArray"), //
		jMethod<::jboolean()>("hasRemaining"), //
		jMethod<::jboolean()>("isDirect"), //
		jMethod<::jboolean()>("isReadOnly"), //
		jMethod<::jint()>("limit"), //
		jMethod<::java::nio::Buffer(::jint)>("limit"), //
		jMethod<::java::nio::Buffer()>("mark"), //
		jMethod<::jint()>("position"), //
		jMethod<::java::nio::Buffer(::jint)>("position"), //
		jMethod<::jint()>("remaining"), //
		jMethod<::java::nio::Buffer()>("reset"), //
		jMethod<::java::nio::Buffer()>("rewind"), //
	};

	template<typename R = ::java::lang::Object, typename... Args>
	auto array(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("array")] != -1);
		return call<R>("array", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto arrayOffset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("arrayOffset")] != -1);
		return call<R>("arrayOffset", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto capacity(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("capacity")] != -1);
		return call<R>("capacity", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::Buffer, typename... Args>
	auto clear(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("clear")] != -1);
		return call<R>("clear", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::Buffer, typename... Args>
	auto flip(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("flip")] != -1);
		return call<R>("flip", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasArray(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasArray")] != -1);
		return call<R>("hasArray", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto hasRemaining(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("hasRemaining")] != -1);
		return call<R>("hasRemaining", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isDirect(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isDirect")] != -1);
		return call<R>("isDirect", std::forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isReadOnly(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("isReadOnly")] != -1);
		return call<R>("isReadOnly", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto limit(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("limit")] != -1);
		return call<R>("limit", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::Buffer, typename... Args>
	auto mark(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("mark")] != -1);
		return call<R>("mark", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto position(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("position")] != -1);
		return call<R>("position", std::forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto remaining(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("remaining")] != -1);
		return call<R>("remaining", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::Buffer, typename... Args>
	auto reset(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("reset")] != -1);
		return call<R>("reset", std::forward<Args>(args)...);
	}

	template<typename R = ::java::nio::Buffer, typename... Args>
	auto rewind(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(std::decay_t<Args>...)>("rewind")] != -1);
		return call<R>("rewind", std::forward<Args>(args)...);
	}

};

#endif
