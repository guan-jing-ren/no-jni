#ifndef java_nio_charset_Charset_HPP
#define java_nio_charset_Charset_HPP

#include "../../../jfwd_decl.hpp"

class ::java::nio::charset::Charset : public jObject<::java::nio::charset::Charset, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_nio_charset / "Charset";

	constexpr static Enume field_signatures{
		cexprstr{"\0"}, //
	};

	constexpr static Enume method_signatures{
		jMethod<::java::util::Set()>("aliases"), //
		jMethod<::java::util::SortedMap()>("availableCharsets"), //
		jMethod<::jboolean()>("canEncode"), //
		jMethod<::jint(::java::lang::Object)>("compareTo"), //
		jMethod<::jint(::java::nio::charset::Charset)>("compareTo"), //
		jMethod<::jboolean(::java::nio::charset::Charset)>("contains"), //
		jMethod<::java::nio::CharBuffer(::java::nio::ByteBuffer)>("decode"), //
		jMethod<::java::nio::charset::Charset()>("defaultCharset"), //
		jMethod<::java::lang::String()>("displayName"), //
		jMethod<::java::lang::String(::java::util::Locale)>("displayName"), //
		jMethod<::java::nio::ByteBuffer(::java::lang::String)>("encode"), //
		jMethod<::java::nio::ByteBuffer(::java::nio::CharBuffer)>("encode"), //
		jMethod<::jboolean(::java::lang::Object)>("equals"), //
		jMethod<::java::nio::charset::Charset(::java::lang::String)>("forName"), //
		jMethod<::jint()>("hashCode"), //
		jMethod<::jboolean()>("isRegistered"), //
		jMethod<::jboolean(::java::lang::String)>("isSupported"), //
		jMethod<::java::lang::String()>("name"), //
		jMethod<::java::nio::charset::CharsetDecoder()>("newDecoder"), //
		jMethod<::java::nio::charset::CharsetEncoder()>("newEncoder"), //
		jMethod<::java::lang::String()>("toString"), //
	};

	template<typename R = ::java::util::Set, typename... Args>
	auto aliases(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("aliases")] != -1);
		return call<R>("aliases", forward<Args>(args)...);
	}

	template<typename R = ::java::util::SortedMap, typename... Args>
	static auto availableCharsets(Args &&...args) {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("availableCharsets")] != -1);
		return scall<R>("availableCharsets", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto canEncode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("canEncode")] != -1);
		return call<R>("canEncode", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto compareTo(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("compareTo")] != -1);
		return call<R>("compareTo", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto contains(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("contains")] != -1);
		return call<R>("contains", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::CharBuffer, typename... Args>
	auto decode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("decode")] != -1);
		return call<R>("decode", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::charset::Charset, typename... Args>
	static auto defaultCharset(Args &&...args) {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("defaultCharset")] != -1);
		return scall<R>("defaultCharset", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto displayName(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("displayName")] != -1);
		return call<R>("displayName", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::ByteBuffer, typename... Args>
	auto encode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("encode")] != -1);
		return call<R>("encode", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto equals(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("equals")] != -1);
		return call<R>("equals", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::charset::Charset, typename... Args>
	static auto forName(Args &&...args) {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("forName")] != -1);
		return scall<R>("forName", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto hashCode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("hashCode")] != -1);
		return call<R>("hashCode", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	auto isRegistered(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isRegistered")] != -1);
		return call<R>("isRegistered", forward<Args>(args)...);
	}

	template<typename R = ::jboolean, typename... Args>
	static auto isSupported(Args &&...args) {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("isSupported")] != -1);
		return scall<R>("isSupported", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto name(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("name")] != -1);
		return call<R>("name", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::charset::CharsetDecoder, typename... Args>
	auto newDecoder(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("newDecoder")] != -1);
		return call<R>("newDecoder", forward<Args>(args)...);
	}

	template<typename R = ::java::nio::charset::CharsetEncoder, typename... Args>
	auto newEncoder(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("newEncoder")] != -1);
		return call<R>("newEncoder", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", forward<Args>(args)...);
	}

};

#endif
