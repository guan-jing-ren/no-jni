#ifndef java_io_StreamTokenizer_HPP
#define java_io_StreamTokenizer_HPP

#include "../../jfwd_decl.hpp"

class ::java::io::StreamTokenizer : public jObject<::java::io::StreamTokenizer, ::java::lang::Object> {
public:
	using jObject::jObject;

	static constexpr auto signature = ::java_io / "StreamTokenizer";

	constexpr static Enume field_signatures{
		jField<::jint>("TT_EOF"), //
		jField<::jint>("TT_EOL"), //
		jField<::jint>("TT_NUMBER"), //
		jField<::jint>("TT_WORD"), //
		jField<::jdouble>("nval"), //
		jField<::java::lang::String>("sval"), //
		jField<::jint>("ttype"), //
	};

	template<typename F = ::jint>
	static auto TT_EOF() {
		static_assert(field_signatures[jField<F>("TT_EOF")] != -1);
		return sat<F>("TT_EOF");
	}

	template<typename F = ::jint>
	static auto TT_EOL() {
		static_assert(field_signatures[jField<F>("TT_EOL")] != -1);
		return sat<F>("TT_EOL");
	}

	template<typename F = ::jint>
	static auto TT_NUMBER() {
		static_assert(field_signatures[jField<F>("TT_NUMBER")] != -1);
		return sat<F>("TT_NUMBER");
	}

	template<typename F = ::jint>
	static auto TT_WORD() {
		static_assert(field_signatures[jField<F>("TT_WORD")] != -1);
		return sat<F>("TT_WORD");
	}

	template<typename F = ::jdouble>
	auto nval() const {
		static_assert(field_signatures[jField<F>("nval")] != -1);
		return at<F>("nval");
	}

	template<typename F = ::java::lang::String>
	auto sval() const {
		static_assert(field_signatures[jField<F>("sval")] != -1);
		return at<F>("sval");
	}

	template<typename F = ::jint>
	auto ttype() const {
		static_assert(field_signatures[jField<F>("ttype")] != -1);
		return at<F>("ttype");
	}

	constexpr static Enume method_signatures{
		jConstructor<::jvoid(::java::io::InputStream)>(), //
		jConstructor<::jvoid(::java::io::Reader)>(), //
		jMethod<::jvoid(::jint)>("commentChar"), //
		jMethod<::jvoid(::jboolean)>("eolIsSignificant"), //
		jMethod<::jint()>("lineno"), //
		jMethod<::jvoid(::jboolean)>("lowerCaseMode"), //
		jMethod<::jint()>("nextToken"), //
		jMethod<::jvoid(::jint)>("ordinaryChar"), //
		jMethod<::jvoid(::jint, ::jint)>("ordinaryChars"), //
		jMethod<::jvoid()>("parseNumbers"), //
		jMethod<::jvoid()>("pushBack"), //
		jMethod<::jvoid(::jint)>("quoteChar"), //
		jMethod<::jvoid()>("resetSyntax"), //
		jMethod<::jvoid(::jboolean)>("slashSlashComments"), //
		jMethod<::jvoid(::jboolean)>("slashStarComments"), //
		jMethod<::java::lang::String()>("toString"), //
		jMethod<::jvoid(::jint, ::jint)>("whitespaceChars"), //
		jMethod<::jvoid(::jint, ::jint)>("wordChars"), //
	};

	template<typename R = ::jvoid, typename... Args>
	auto commentChar(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("commentChar")] != -1);
		return call<R>("commentChar", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto eolIsSignificant(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("eolIsSignificant")] != -1);
		return call<R>("eolIsSignificant", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto lineno(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("lineno")] != -1);
		return call<R>("lineno", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto lowerCaseMode(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("lowerCaseMode")] != -1);
		return call<R>("lowerCaseMode", forward<Args>(args)...);
	}

	template<typename R = ::jint, typename... Args>
	auto nextToken(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("nextToken")] != -1);
		return call<R>("nextToken", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto ordinaryChar(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("ordinaryChar")] != -1);
		return call<R>("ordinaryChar", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto ordinaryChars(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("ordinaryChars")] != -1);
		return call<R>("ordinaryChars", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto parseNumbers(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("parseNumbers")] != -1);
		return call<R>("parseNumbers", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto pushBack(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("pushBack")] != -1);
		return call<R>("pushBack", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto quoteChar(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("quoteChar")] != -1);
		return call<R>("quoteChar", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto resetSyntax(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("resetSyntax")] != -1);
		return call<R>("resetSyntax", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto slashSlashComments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("slashSlashComments")] != -1);
		return call<R>("slashSlashComments", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto slashStarComments(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("slashStarComments")] != -1);
		return call<R>("slashStarComments", forward<Args>(args)...);
	}

	template<typename R = ::java::lang::String, typename... Args>
	auto toString(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("toString")] != -1);
		return call<R>("toString", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto whitespaceChars(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("whitespaceChars")] != -1);
		return call<R>("whitespaceChars", forward<Args>(args)...);
	}

	template<typename R = ::jvoid, typename... Args>
	auto wordChars(Args &&...args) const {
		static_assert(method_signatures[jMethod<R(decay_t<Args>...)>("wordChars")] != -1);
		return call<R>("wordChars", forward<Args>(args)...);
	}

};

#endif
